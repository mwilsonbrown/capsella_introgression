---
title: "Capsella local ancestry introgression and PopGen"
author: "Maya Wilson Brown"
date: "2024-03-25"
output: html_document
---

##### Setup 
```{r libraries}
library(stringr)
library(dplyr)
library(ggplot2)
library(rnaturalearth)
```


```{r sourcing functions}
source("~/Documents/PhD/Research/capsella_introgression/capsella_introgression_func.R")
```

# Introgression in Capsella bursa-pastoris

#### Data Preparation

```{r capsella sequenced information}
# load capsella whole genome sequencing information
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

```{r defined populations}
#load C. bursa-pastoris population information
k3pops <- read.csv("~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", header = T, sep = "\t")

# ATM I do not have nyc samples in here so I will temporarily add them
nyc_pops <- wgs[which(wgs$citation == "R.Panko"), c("vcf_sample_name", "sample_name", "state", "latitude", "longitude", "latlong_approx")]

# change state column name to match pops df
colnames(nyc_pops)[3] <- "k3population"

# join data frames
pops <- rbind(k3pops, nyc_pops)
```

# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern from viterbi output folder
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data; each sample gets its own list element df
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name

# produces list where each element is a df of the results for one sample
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit, idcol = "vcf_sample_name")

# order sample names to be in ancestry proportion order
#lvl.order <- c(anc[1:nrow(sample_names_fam), "vcf_sample_name"])$vcf_sample_name

# explicitly make 'vcf_sample_name' a factor and order by ancestry proportion
#vit_all$vcf_sample_name <- factor(vit_all$vcf_sample_name, levels = lvl.order)
```

I will start by combining the viterbi decoding with the whole genome sequencing data

```{r}
# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, pops)

# order the scaffold levels
vit_all$chrom <- factor(vit_all$chrom, levels = paste0("jlSCF_", 9:16))
```
# Exploratory
The first thing I want to check is that the proportion of *C. rubella* ancestry is less than the proportion of *C. bursa-pastoris* ancestry.
```{r}
# proportion of local ancestry
colSums(vit_all[vit_all$ancestry == "rubella", "tract_length"])/colSums(vit_all[, "tract_length"])

# bursa-pastoris
colSums(vit_all[vit_all$ancestry == "bursa_pastoris", "tract_length"])/colSums(vit_all[, "tract_length"])

# heterozygous
colSums(vit_all[vit_all$ancestry == "heterozygous", "tract_length"])/colSums(vit_all[, "tract_length"])
```

Now, it might be interesting to look at the distributions of the tract lengths. I Expect them to be something close to a poisson distribution.
```{r}
# tract length distribution
tl_dist <- ggplot() + 
  geom_histogram(data=vit_all, aes(tract_length, fill=ancestry), bins = 100) +
  theme_bw() +
  facet_grid(ancestry~chrom) +
  theme(legend.position = "none")
tl_dist
ggsave(paste0(temp_plotdir, "tract_len.png"), tl_dist, width = 5, height = 10)
```

# Introgression Plots

```{r nyc introgression plot}
# plot with funtion
ny_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = c("NY", "NJ"))
ggsave(paste0(temp_plotdir, "ny_viterbi_SCF16_new.png"), ny_16, units = "in", height = 7, width = 12)

# plot with funtion
eu_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "N_Europe")
ggsave(paste0(temp_plotdir, "eu_viterbi_SCF16_new.png"), eu_16, units = "in", height = 7, width = 12)

# plot with funtion
mena_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "MENA")
ggsave(paste0(temp_plotdir, "mena_viterbi_SCF16_new.png"), mena_16, units = "in", height = 7, width = 12)

# plot with funtion
easian_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "E_Asia")
ggsave(paste0(temp_plotdir, "easia_viterbi_SCF16_new.png"), easian_16, units = "in", height = 7, width = 12)
```


```{r nyc_introgression_plot_allScaffolds}
ggplot() + geom_segment(data = subset(vit_all, k4vsNY_pop == "nyc"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) +
  scale_color_manual(values=anc.cols) + 
  ggtitle("New York introgression patterns") + 
  ylab("position") + xlab("Sample Name") + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8)) +
   facet_wrap(~chrom, scales = "free_y")

nyc_allc <- viterbi_columns_plot_allChr(vit_all, population = c("NY", "NJ"))

# why is the order wrong >:(
ggsave(paste0(temp_plotdir,"ny_viterbi_all.png"),nyc_allc, units = "in", height = 12, width = 19)
```

###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

Starting with the NYC samples
It may be possible to make a co-occurrence matrix with the bed output files.
```{r}
ny_rub_by_sample <- bed_by_sample(vit_all, ancestry = "rubella",
                                  population = c("NY", "NJ"),
                                  outdir = bed_files)
```

Now do the same for Mediterranean samples.

```{r mediterranenan samples, eval=FALSE}
mena_rub_by_sample <- bed_by_sample(vit_all, ancestry = "rubella",
                                  population = "MENA",
                                  outdir = bed_files)
```

And N. European samples
```{r write European to bed files}
# Warning: this function writes files automatically
eu_rub_by_sample <- bed_by_sample(vit_all, ancestry = "rubella",
                                  population = "N_Europe",
                                  outdir = bed_files)
```

### Introgressed region frequency
This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and **multi-inter** from BEDTools
```{r}
# load multi inter output file
nyc_inter <- read.delim("~/Documents/PhD/Research/admixture/old/nyc_multiinter_rubella.txt")

# smaller working file since BEDTools outputs more information than I need
nyc_inter_sm <- nyc_inter[,1:4]
```

```{r NY Crubella chunks gradient}
# mistyrose = #FFE4E1, violetred4 = #8B2252
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = nyc_inter_sm, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("New York introgressed region frequency") + theme_classic()

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_freq.png", units = "in", height = 12, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = nyc_inter_sm, binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
 
I will define an introgressed segment as common if it is present in at least 33 individuals (a little over 50% of our NYC samples)

```{r}
# get the common chunks
nyc_common_chunks <- nyc_inter_sm[nyc_inter_sm$num >= 33,]
```


```{r join common with nyc data}
#prepping to join with larger dataset
nyc_common_chunks$vcf_sample_name <- "common"
nyc_common_chunks$ancestry <- "rubella"

ny_rubella_common <- rbind(ny_rubella_tracts, nyc_common_chunks, fill=T)
```

```{r nyc and common rubella chunks}
ggplot() + geom_segment(data = subset(ny_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: New York") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

# Looks quite good actually!
ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_common_introgressed.png", units = "in", height = 12, width = 12)
```


```{r nyc and common rubella chunks all}
ggplot() + geom_segment(data = ny_rubella_common, aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("New York introgrressed regions shared by 33 or more individuals") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10)) +
  facet_wrap(~chrom, scales = "free_y")

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_common.png", units = "in", height = 12, width = 19)
```

Now again with the Mediterranean samples
```{r mediterranean, eval=FALSE}
# load file
med_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/med_multiinter_rubella.txt")

# smaller working file since BEDTools outputs more information than I need
med_inter <- med_inter[,1:4]

# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = med_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("Mediterranean introgressed regions") + theme_classic()

#ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/med_introgressed_freq.png", units = "in", height = 12, width = 12)

# "common" depends on the scaffold
ggplot() + geom_histogram(data = med_inter, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()

# get the common chunks
med_common_chunks <- med_inter[med_inter$num >= 4,]

#prepping to join with larger dataset
med_common_chunks$vcf_sample_name <- "common"
med_common_chunks$ancestry <- "rubella"

med_rubella_common <- rbind(med_rubella_tracts, med_common_chunks, fill=T)

ggplot() + geom_segment(data = subset(med_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: Mediterranean") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))
```

##### MultiInter by K4 group
An easy way to figure out which regions are shared by all of the groups and private to each group is to do the multi-inter analysis on all of the capsella bursa-pastoris in the European lineage.

```{r}
# load file
eu_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/k4European_cbp_multiinter_rubella.txt")

# smaller working file but include which individuals are in each row
sm_eu_inter <- eu_inter[,1:5]

# column names to match individuals to numbers in small multi-inter df
eu_names <- colnames(eu_inter[6:length(colnames(eu_inter))])

# save indices for each population
ny_indx <- which(grepl( "ny_rubella_chunks.bed", eu_names, fixed = TRUE))
neu_indx <- which(grepl( "ne_rubella_chunks.bed", eu_names, fixed = TRUE))
cen_indx <- which(grepl( "cen_rubella_chunks.bed", eu_names, fixed = TRUE))
med_indx <- which(grepl( "med_rubella_chunks.bed", eu_names, fixed = TRUE))

```

Now I would like to determine a series of tests
```{r}
# plot rubella regions common to all in European cluster
# num column should be 91, the same length of named columns
ggplot() + geom_segment(data = subset(sm_eu_inter, num == length(eu_names)), aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "black", low = "violet") + ggtitle("introgressed regions in all European lineage") + theme_classic()

#ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/allEuLineage_introgressed_v.png", units = "in", height = 12, width = 12)
```
What is the distribution of shared regions
```{r}
ggplot() + geom_histogram(data=sm_eu_inter, aes(x=num), binwidth = 1) + theme_bw()
```

```{r}
# plot rubella regions common to all in European cluster
ggplot() + geom_segment(data = sm_eu_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "black", low = "violet") + ggtitle("introgressed regions across all European lineage") + theme_classic()

#ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/allEuLineage_introgressed_freq_v.png", units = "in", height = 12, width = 12)

```

Want to combine the "everybody" image with frequency image
```{r}
# Works, but does not show on the legend yet.
ggplot() + geom_segment(data = sm_eu_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") +
  geom_segment(data = subset(sm_eu_inter, num == length(eu_names)), aes(x=chrom, xend=chrom, y=start, yend=end),colour= "green", linewidth = 10) + ggtitle("introgressed regions across all European lineage") + theme_classic()
```
Might be able to get the legend to work by looking at the stack overflow answer https://stackoverflow.com/questions/67082430/how-to-highlight-a-single-value-on-a-continuous-color-scale-in-ggplot2

```{r}
# determining regions private to each group, but also found in all members
med_private <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, med_indx)
})

sum(med_private)
```
To get the number of those that are private but not present in all members of the group, I can use is.element?
```{r}
# only in Mediterranean group
ggplot() + geom_segment(data = sm_eu_inter[which(med_private),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("introgressed regions private to Mediterranean group") + theme_classic()

ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/Med_private_introgressed.png", units = "in", height = 12, width = 12)
```
No regions found to be private to Northern European group, or NYC and present in all members of the group.

To get the number of those that are private but not present in all members of the group, I can use is.element? or interset?
```{r}
# private to mediterranean but not in all samples of the group
med_p_div <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% med_indx)
})

sum(med_p_div)
```
Okay so 64 regions are *only* in Mediterranean but *not all the individuals* have them.

We know NYC does not have private and common regions, but what about just private?

```{r}
# private to New York/New Jersey but not in all samples of the group
ny_p_div <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% ny_indx)
})

sum(ny_p_div)
```
46!

Let's try to make a figure for that.
```{r}
ggplot() + 
  geom_segment(data = sm_eu_inter[which(ny_p_div),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "black", low = "violet") + 
  ggtitle("Introgressed regions private to New York") + theme_classic()

ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/Nyc_private_notAll_introgressed_v.png", units = "in", height = 12, width = 12)
```
```{r}
# maximum number of individuals that share a private region?
max(sm_eu_inter[which(ny_p_div), "num"])
```

Now I can compare NYC to other regions. Here I am attempting to find regions that are only in New York and other groups, but may not be present in all individuals
```{r}
# private to New York/New Jersey but not in all samples of the group
ny_neu_p <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% c(ny_indx, neu_indx))
})

# how many?
sum(ny_neu_p)

# distribution of sharing
ggplot() + geom_histogram(data = sm_eu_inter[which(ny_neu_p),], aes(x=num), binwidth = 1)

# size of chunks generally
ny_neu_df <- sm_eu_inter[which(ny_neu_p),] %>% mutate(chunk_size = end - start)

#plot
ggplot() + geom_histogram(data = subset(ny_neu_df, num > 2), aes(x=chunk_size))

```

```{r}
#chromosome plot
ggplot() + 
  geom_segment(data = sm_eu_inter[which(ny_neu_p),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + 
  ggtitle("Introgressed regions only in NYC and N. Eruope") + theme_classic()
```
How about Mediterranean
```{r}
# private to New York/New Jersey but not in all samples of the group
ny_med_p <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% c(ny_indx, med_indx))
})

# how many?
sum(ny_med_p)

# distribution of sharing
ggplot() + geom_histogram(data = sm_eu_inter[which(ny_med_p),], aes(x=num), binwidth = 1)
```
Plot of them

```{r}
#chromosome plot
ggplot() + 
  geom_segment(data = sm_eu_inter[which(ny_med_p),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + 
  ggtitle("Introgressed regions only in NYC or N. Mediterranean") + theme_classic()
```
To make this make more logical sense, I need to find a way to test if the region is in at least one NY individual **and** at least 1 Mediterranean individual.

```{r}
# private and in all members of central Asian group
cen_private <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, cen_indx)
})

sum(cen_private)
```

So now we know that only the mediterranean region and central asia have introgressed regions that are private to those populations. It may now be interestigng to find regions that are shared only between nyc and those other two populations.
```{r}
# are there any in NYC and Central Asia only?
cen_ny <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, c(ny_indx,cen_indx))
})

sum(cen_ny)
```

```{r}
# are there any in NYC and mediterranean only?
med_ny <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, c(ny_indx,med_indx))
})

sum(med_ny)
```
No!

I think from this, we can conclude that alleles shared across all European populations are not due to shared introgression. So the Admixture I find between NYC and Central Asia, and the mediterranean are not due to shared introgressed regions.

#### Genic Content
We may be interested in comparing the number of genes in introgressed regions vs non-introgressed regions. To do this, we can use BEDTools intersect to see how many basepairs of genes from a Genome Feature File (GFF) intersect with basepairs from introgressed or non-introgressed regions.

I will create BEDfiles of non-intorgressed regions as before.

#### Pi in introgressed regions
To look at pairwise diversity in introgressed regions, first, I assigned individual Capsella bursa-pastoris to different populations where individuals are a part of 3 main lineages: Asian, with no introgression; Mediterranean, with introgression; and European/NewYorker, with introgression.

First, I looked at pairwise diversity in each population using sliding windows of 10,000 base pairs across the whole genome.

*ANOTHER THOUGHT*
Another analysis that may be interesting is to look at PI (pairwise diversity) along the genome within NYC populations to identify regions with higher or lower PI than expected?

But first, I am interested in Dxy comparing NYC regions to other.

The first thing I need to do is create a mapping list for Pixy defined populations for comparison.

The main question here might be how extremely differentiated sites compare to genomic regions of interest (either introgressed or not)

Might want to compare the levels between the Northern European population and the Southern European population, compared to NYC and California when I get that data.

```{r}
pi <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_pi.txt")
```

```{r}
pi %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi across whole genome") +
  theme_bw()
```


```{r}
dxy <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_dxy.txt")
```

```{r}
dxy %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_dxy, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Dxy across whole genome") +
  theme_bw()
```


```{r}
dxy[dxy$chromosome == "SCF_10",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_dxy, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Dxy across whole genome") +
  theme_bw()
```
```{r}
fst <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_fst.txt")
```

```{r}
fst[fst$chromosome == "SCF_10",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_wc_fst, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Fst across whole genome") +
  theme_bw()
```

Pixy Plot
```{r}

```

