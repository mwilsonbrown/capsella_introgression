---
title: "Capsella local ancestry introgression and PopGen"
author: "Maya Wilson Brown"
date: "2024-03-25"
output: html_document
---

##### Setup 
```{r libraries}
library(stringr)
library(dplyr)
library(ggplot2)
library(rnaturalearth)
```


```{r sourcing functions}
source("~/Documents/PhD/Research/capsella_introgression/capsella_introgression_func.R")
```

# Introgression in Capsella bursa-pastoris

#### Data Preparation

```{r capsella sequenced information}
# load capsella whole genome sequencing information
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

```{r defined populations}
#load C. bursa-pastoris population information
k3pops <- read.csv("~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", header = T, sep = "\t")

# ATM I do not have nyc samples in here so I will temporarily add them
nyc_pops <- wgs[which(wgs$citation == "R.Panko"), c("vcf_sample_name", "sample_name", "state", "latitude", "longitude", "latlong_approx")]

# change state column name to match pops df
colnames(nyc_pops)[3] <- "k3population"

# join data frames
pops <- rbind(k3pops, nyc_pops)
```

# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern from viterbi output folder
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data; each sample gets its own list element df
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name

# produces list where each element is a df of the results for one sample
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit, idcol = "vcf_sample_name")

# order sample names to be in ancestry proportion order
#lvl.order <- c(anc[1:nrow(sample_names_fam), "vcf_sample_name"])$vcf_sample_name

# explicitly make 'vcf_sample_name' a factor and order by ancestry proportion
#vit_all$vcf_sample_name <- factor(vit_all$vcf_sample_name, levels = lvl.order)
```

I will start by combining the viterbi decoding with the whole genome sequencing data

```{r}
# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, pops)

# order the scaffold levels
vit_all$chrom <- factor(vit_all$chrom, levels = paste0("jlSCF_", 9:16))
```
# Exploratory
The first thing I want to check is that the proportion of *C. rubella* ancestry is less than the proportion of *C. bursa-pastoris* ancestry.
```{r}
# proportion of local ancestry
colSums(vit_all[vit_all$ancestry == "rubella", "tract_length"])/colSums(vit_all[, "tract_length"])

# bursa-pastoris
colSums(vit_all[vit_all$ancestry == "bursa_pastoris", "tract_length"])/colSums(vit_all[, "tract_length"])

# heterozygous
colSums(vit_all[vit_all$ancestry == "heterozygous", "tract_length"])/colSums(vit_all[, "tract_length"])
```

Now, it might be interesting to look at the distributions of the tract lengths. I Expect them to be something close to a poisson distribution.
```{r}
# tract length distribution
tl_dist <- ggplot() + 
  geom_histogram(data=vit_all, aes(tract_length, fill=ancestry), bins = 40) +
  scale_fill_manual(values = anc.cols) +
  theme_bw() +
  facet_grid(chrom~ancestry, scales = "free") +
  theme(legend.position = "none")
tl_dist
ggsave(paste0(temp_plotdir, "tract_len.png"), tl_dist, width = 7, height = 5)
```
Most tracts are short, and bursa-pastoris tracts are on average, longer than others. Heterozygous tracts are the shortest.
# Introgression Plots

```{r nyc introgression plot}
# plot with funtion
ny_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = c("NY", "NJ"))
ggsave(paste0(temp_plotdir, "ny_viterbi_SCF16_new.png"), ny_16, units = "in", height = 7, width = 12)

# plot with funtion
eu_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "N_Europe")
ggsave(paste0(temp_plotdir, "eu_viterbi_SCF16_new.png"), eu_16, units = "in", height = 7, width = 12)

# plot with funtion
mena_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "MENA")
ggsave(paste0(temp_plotdir, "mena_viterbi_SCF16_new.png"), mena_16, units = "in", height = 7, width = 12)

# plot with funtion
easian_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "E_Asia")
ggsave(paste0(temp_plotdir, "easia_viterbi_SCF16_new.png"), easian_16, units = "in", height = 7, width = 12)
```


```{r nyc_introgression_plot_allScaffolds}
nyc_allc <- viterbi_columns_plot_allChr(vit_all, population = c("NY", "NJ"))

# why is the order wrong >:(
ggsave(paste0(temp_plotdir,"ny_viterbi_all2.png"),nyc_allc, units = "in", height = 12, width = 19)
```

###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

Starting with the NYC samples
It may be possible to make a co-occurrence matrix with the bed output files.
```{r}
ny_rub_by_sample <- bed_by_sample(vit_all, anc = "rubella", population = c("NY", "NJ"), outdir = bed_files)
```

Now do the same for Mediterranean samples.

```{r mediterranenan samples, eval=FALSE}
mena_rub_by_sample <- bed_by_sample(vit_all, anc = "rubella",
                                  population = "MENA",
                                  outdir = bed_files)
```

And N. European samples
```{r write European to bed files}
# Warning: this function writes files automatically
eu_rub_by_sample <- bed_by_sample(vit_all, anc = "rubella",
                                  population = "N_Europe",
                                  outdir = bed_files)
```

### Introgressed region frequency
This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and **multi-inter** from BEDTools

```{bash, code = readLines("multiinter.sh")}
```

Let's take a look at the output
```{r}
# load multi inter output file
nyc_inter <- read.csv(paste0("~/Documents/PhD/Research/capsella_introgression/nyc_multiinter_rubella.txt"), header = T, sep = "\t")

# You can pass sample names to BEDtools but I will just fix them here
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "X.mnt.scratch.wils1582.bed_files.") #remove directory info
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "_NY_rubella.bed") #remove other info

# relevel factors
nyc_inter$chrom <- factor(nyc_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r NY Crubella chunks gradient}
# mistyrose = #FFE4E1, violetred4 = #8B2252
# gradient plot where darker colors mean more individuals share an introgressed chunk
# ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("New York introgressed region frequency") + theme_classic()

ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_scico(palette = 'acton', direction = -1) + ggtitle("New York introgressed region frequency") + theme_classic()

#ggsave(paste0(temp_plotdir,"nyc_introgressed_freq.png"), units = "in", height = 12, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = nyc_inter[,1:4], binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
 
I will define an introgressed segment as common if it is present in at least 33 individuals (a little over 50% of our NYC samples)

```{r}
# get the common chunks
nyc_common_chunks <- nyc_inter_sm[nyc_inter_sm$num >= 33,]
```


```{r join common with nyc data}
#prepping to join with larger dataset
nyc_common_chunks$vcf_sample_name <- "common"
nyc_common_chunks$ancestry <- "rubella"

ny_rubella_common <- rbind(ny_rubella_tracts, nyc_common_chunks, fill=T)
```

```{r nyc and common rubella chunks}
ggplot() + geom_segment(data = subset(ny_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: New York") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

# Looks quite good actually!
ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_common_introgressed.png", units = "in", height = 12, width = 12)
```


```{r nyc and common rubella chunks all}
ggplot() + geom_segment(data = ny_rubella_common, aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("New York introgrressed regions shared by 33 or more individuals") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10)) +
  facet_wrap(~chrom, scales = "free_y")

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_common.png", units = "in", height = 12, width = 19)
```

Now again with the Mediterranean samples
```{r mediterranean, eval=FALSE}
# load file
mena_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/mena_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(mena_inter) <- str_remove(colnames(mena_inter), "X.mnt.scratch.wils1582.bed_files.") #remove directory info
colnames(mena_inter) <- str_remove(colnames(mena_inter), "_NY_rubella.bed") #remove other info

# relevel factors
mena_inter$chrom <- factor(mena_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r}

# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = mena_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("Middle East, North African, and Mediterranean introgressed regions") + theme_classic()

#ggsave(paste0(temp_plotdir,"mena_introgressed_freq.png"), units = "in", height = 12, width = 12)
```
I will plot the N. European separately just for posterity but I am really more interested in the shared and private regions.
##### MultiInter by K4 group
An easy way to figure out which regions are shared by all of the groups and private to each group is to do the multi-inter analysis on all of the capsella bursa-pastoris in the European lineage.

```{r}
# load file
all_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/all_multiinter_rubella.txt")

# You can pass sample names to BEDtools but I will just fix them here
colnames(all_inter) <- str_remove(colnames(all_inter), "X.mnt.scratch.wils1582.bed_files.") #remove directory info

# column names to match individuals to numbers in small multi-inter df
all_names <- colnames(all_inter[6:length(colnames(all_inter))])

# save indices for each population
nyc_indx <- which(grepl( "NY_rubella.bed", all_names, fixed = TRUE))
neu_indx <- which(grepl( "N_Europe_rubella.bed", all_names, fixed = TRUE))
mena_indx <- which(grepl( "MENA_rubella.bed", all_names, fixed = TRUE))
```

Now I would like to determine a series of tests

```{r}
# distribution of region sharing
ggplot() + geom_histogram(data = all_inter[,1:4], binwidth = 5, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
##### High Frequency shared regions
```{r}
#regions shared by all
all_inter[which(all_inter$num == 100), 1:4]
```


There is one 4000bp region on chromosome 12 that is shared by all the introgressed populations individuals. This region is know of note for population genetic studies as it should be pretty old to be shared among all.

It would be useful to be able to plot these things on top of one another
```{r}
#tuncate df
sm_all_inter <- all_inter[,1:5]

all_int_mat <- str_split_fixed(all_inter$list, ",", n=100)

#forcing matrix to numeric fills blanks with NA
class(all_int_mat) <- "numeric"

#combine
test <- cbind(sm_all_inter, data.frame(all_int_mat))

#pivot longer
test2 <- pivot_longer(test, cols = c(paste0("X", 1:100)), values_drop_na = T)

# check the last row of each segment is the same number as name?
```

Now to drop name column and assign population to each integer
```{r}
# drop name column
test2 <- subset(test2, select = -c(name, list))

# new column where indices indicate population
test3 <- test2 %>% mutate(population = case_when(value %in% nyc_indx ~ "NYC",
                                        value %in% neu_indx ~ "N. Europe",
                                        value %in% mena_indx ~ "MENA"))
```

Just working with one dataset at a time
```{r}
ggplot() + geom_linerange(data = test3, aes(x=population, ymin=start, ymax=end, color = num), linewidth = 5)+ coord_flip() + facet_wrap(~chrom, scales = "free", nrow = 8)

#ggsave("~/Desktop/test_plot1.png", width = 5, height = 11)
```

Once I have the above, then maybe I can split it into dataframes?
```{r}
test4 <- split(test3, test3$population)
```


```{r}
#withggnewscale
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + facet_wrap(~chrom, scales = "free", nrow = 8) + coord_flip() +
  geom_linerange(data = test4[[1]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = c('#99000d', '#fee5d9')) +
  new_scale_color() + 
  geom_linerange(data = test4[[2]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = c('#084594', '#4292c6')) +
  new_scale_color() + 
  geom_linerange(data = test4[[3]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = c('mediumorchid4', 'lightpink'))

ggsave("~/Desktop/test_plot2.png", width = 5, height = 11)
```

I think in reality, I wanted all the within population bed files in separate data frames?

Okay, I think it makes sense to have each of the populations have their own number scale

```{r}
#withggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + facet_wrap(~chrom, scales = "free", nrow = 8) + coord_flip() +
  geom_linerange(data = test4[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = test4[[2]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = test4[[3]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1)

ggsave("~/Desktop/test_plot3.png", width = 5, height = 11)
```
As mentioned above, it is actually more intitituve to me and beneficial to have each population on their own number scale. I will achieve that by joining the dfs?
```{r N. European, eval=FALSE}
# load file
neu_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/neu_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(neu_inter) <- str_remove(colnames(neu_inter), "X.mnt.scratch.wils1582.bed_files.") #remove directory info
colnames(neu_inter) <- str_remove(colnames(neu_inter), "_N_Europe_rubella.bed") #remove other info

# relevel factors
neu_inter$chrom <- factor(neu_inter$chrom, levels = paste0("jlSCF_", 9:16))
```


```{r}
# add population indicators to all
nyc_inter$population <- "NYC"
neu_inter$population <- "N. Europe"
mena_inter$population <- "MENA"

# combine the relevant part of the dfs
c_inter <- list(nyc_inter[,c("chrom","start","end","num","population")],neu_inter[,c("chrom","start","end","num","population")],mena_inter[,c("chrom","start","end","num","population")])
```

Attempt to generate plot?
```{r}
#withggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + facet_wrap(~chrom, scales = "free", nrow = 2, ncol=4) + coord_flip() +
  theme_bw()+
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)

ggsave("~/Desktop/test_plot4.png", width = 11, height = 5)
```

As mentioned above, I can look at different combination of regions. However, the set math works best when the list

```{r}
# first, regions where any element of nyc is present and elements of mena and europe are not
nyc_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, nyc_indx)) >= 1, "in NYC", NA)
})
```
There is another group which I may be interested in, which is the NJ population by itself. Thats population 24 and I can print the names to know they correspond to indices 43,44,45
```{r}
nj_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, 43:45)) >= 1, "in NJ", NA)
})
```

There is a more elegant way to do this (probably with casewhen) but I can fix that later. The plan is to get a vector of region status for each population
```{r}
# middle east and north africa
mena_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, mena_indx)) >= 1, "in MENA", NA)
})

# Europe
neu_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, neu_indx)) >= 1, "in N. Europe", NA)
})

# combine them
chunk_status <- data.frame(nyc_status,nj_status,mena_status,neu_status)

ind <- rowSums(is.na(chunk_status)) == ncol(chunk_status)
ind2 <- rowSums(is.na(all_stat[,6:8])) == ncol(all_stat[,6:8])
```

Bind with actual bed data and check which regions are in or out of each population
```{r}
all_stat <- cbind(all_inter[,1:5], chunk_status )
```

```{r}
# filter keeps rows that match a condition
# keep rows where europe and mena are NA (implying nyc is not, because I do not have empty regions)
seg_nyc_only <- all_stat %>%
   filter(if_all(c(mena_status,neu_status), is.na))

# present in NY/NJ and Europe; absent from MENA
seg_nyc_eu <- all_stat %>%
   filter(!(if_any(c(nyc_status, neu_status), is.na)) & is.na(mena_status))

# present in NY/NJ and MENA; absent from Europe
seg_nyc_mena <- all_stat %>%
   filter(!(if_any(c(nyc_status, mena_status), is.na)) & is.na(neu_status))

# present in NJ and Europe, which may drive the relationship between the two
seg_nj_neu <- all_stat %>%
   filter(!(if_any(c(nj_status, neu_status), is.na)) & is.na(mena_status))

# only in NJ (of which NY is inclusive)
seg_nj <- all_stat %>%
   filter(!is.na(nj_status) & if_all(c(neu_status, mena_status), is.na))

# private to NJ (not found elsewhere in NY)
seg_nj[which(seg_nj$num == 3),]
```
There is only `r nrow(seg_nj)` region present in NJ and not found elsewhere in the NYC group, nor is it found in other sampled introgressed populations. There are `r nrow(seg_nyc_only)` introgressed regions only found in NYC, that have not been sampled in the MENA nor the N. European population.

There are introgressed regions that are only found in NJ and a sample in the Mediterranean population (namely KYRG-3-14, which is index 97 in this data): number = `r nrow(which(seg_nyc_mena$num ==4 & seg_nyc_mena$list == c(43,44,45,97)`

Visual inspection of the data shows there are only two regions that are in the N. European group and NJ and not in the rest of NYC, and those are two regions on scaffold 15
```{r}
seg_nj_neu[107:108,]

seg_nj_neu[107:108,"end"] - seg_nj_neu[107:108,"start"]
```
4k and 12k bp respectively.

### Older code
Want to combine the "everybody" image with frequency image
```{r}
# Works, but does not show on the legend yet.
ggplot() + geom_segment(data = sm_eu_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") +
  geom_segment(data = subset(sm_eu_inter, num == length(eu_names)), aes(x=chrom, xend=chrom, y=start, yend=end),colour= "green", linewidth = 10) + ggtitle("introgressed regions across all European lineage") + theme_classic()
```
Might be able to get the legend to work by looking at the stack overflow answer https://stackoverflow.com/questions/67082430/how-to-highlight-a-single-value-on-a-continuous-color-scale-in-ggplot2

```{r}
# determining regions private to each group, but also found in all members
med_private <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, med_indx)
})

sum(med_private)
```
To get the number of those that are private but not present in all members of the group, I can use is.element?
```{r}
# only in Mediterranean group
ggplot() + geom_segment(data = sm_eu_inter[which(med_private),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("introgressed regions private to Mediterranean group") + theme_classic()

ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/Med_private_introgressed.png", units = "in", height = 12, width = 12)
```
No regions found to be private to Northern European group, or NYC and present in all members of the group.

To get the number of those that are private but not present in all members of the group, I can use is.element? or interset?
```{r}
# private to mediterranean but not in all samples of the group
med_p_div <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% med_indx)
})

sum(med_p_div)
```
Okay so 64 regions are *only* in Mediterranean but *not all the individuals* have them.

We know NYC does not have private and common regions, but what about just private?

```{r}
# private to New York/New Jersey but not in all samples of the group
ny_p_div <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% ny_indx)
})

sum(ny_p_div)
```
46!

Let's try to make a figure for that.
```{r}
ggplot() + 
  geom_segment(data = sm_eu_inter[which(ny_p_div),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "black", low = "violet") + 
  ggtitle("Introgressed regions private to New York") + theme_classic()

ggsave("~/Documents/PhD/Research/capsella_introgression/alt_plots_temp/Nyc_private_notAll_introgressed_v.png", units = "in", height = 12, width = 12)
```
```{r}
# maximum number of individuals that share a private region?
max(sm_eu_inter[which(ny_p_div), "num"])
```

Now I can compare NYC to other regions. Here I am attempting to find regions that are only in New York and other groups, but may not be present in all individuals
```{r}
# private to New York/New Jersey but not in all samples of the group
ny_neu_p <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% c(ny_indx, neu_indx))
})

# how many?
sum(ny_neu_p)

# distribution of sharing
ggplot() + geom_histogram(data = sm_eu_inter[which(ny_neu_p),], aes(x=num), binwidth = 1)

# size of chunks generally
ny_neu_df <- sm_eu_inter[which(ny_neu_p),] %>% mutate(chunk_size = end - start)

#plot
ggplot() + geom_histogram(data = subset(ny_neu_df, num > 2), aes(x=chunk_size))

```

```{r}
#chromosome plot
ggplot() + 
  geom_segment(data = sm_eu_inter[which(ny_neu_p),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + 
  ggtitle("Introgressed regions only in NYC and N. Eruope") + theme_classic()
```
How about Mediterranean
```{r}
# private to New York/New Jersey but not in all samples of the group
ny_med_p <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the all elements are within test vector
all(nel %in% c(ny_indx, med_indx))
})

# how many?
sum(ny_med_p)

# distribution of sharing
ggplot() + geom_histogram(data = sm_eu_inter[which(ny_med_p),], aes(x=num), binwidth = 1)
```
Plot of them

```{r}
#chromosome plot
ggplot() + 
  geom_segment(data = sm_eu_inter[which(ny_med_p),], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + 
  ggtitle("Introgressed regions only in NYC or N. Mediterranean") + theme_classic()
```
To make this make more logical sense, I need to find a way to test if the region is in at least one NY individual **and** at least 1 Mediterranean individual.

```{r}
# private and in all members of central Asian group
cen_private <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, cen_indx)
})

sum(cen_private)
```

So now we know that only the mediterranean region and central asia have introgressed regions that are private to those populations. It may now be interestigng to find regions that are shared only between nyc and those other two populations.
```{r}
# are there any in NYC and Central Asia only?
cen_ny <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, c(ny_indx,cen_indx))
})

sum(cen_ny)
```

```{r}
# are there any in NYC and mediterranean only?
med_ny <- apply(sm_eu_inter["list"], 1, function(x){
# for each row
# take the value of column 'list'
# make it a vector
v <- c(x)
# split elements into characters
el <- str_split_1(v, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
setequal(nel, c(ny_indx,med_indx))
})

sum(med_ny)
```
No!

I think from this, we can conclude that alleles shared across all European populations are not due to shared introgression. So the Admixture I find between NYC and Central Asia, and the mediterranean are not due to shared introgressed regions.

#### Genic Content
We may be interested in comparing the number of genes in introgressed regions vs non-introgressed regions. To do this, we can use BEDTools intersect to see how many basepairs of genes from a Genome Feature File (GFF) intersect with basepairs from introgressed or non-introgressed regions.

I will create BEDfiles of non-intorgressed regions as before.

#### Pi in introgressed regions
To look at pairwise diversity in introgressed regions, first, I assigned individual Capsella bursa-pastoris to different populations where individuals are a part of 3 main lineages: Asian, with no introgression; Mediterranean, with introgression; and European/NewYorker, with introgression.

First, I looked at pairwise diversity in each population using sliding windows of 10,000 base pairs across the whole genome.

*ANOTHER THOUGHT*
Another analysis that may be interesting is to look at PI (pairwise diversity) along the genome within NYC populations to identify regions with higher or lower PI than expected?

But first, I am interested in Dxy comparing NYC regions to other.

The first thing I need to do is create a mapping list for Pixy defined populations for comparison.

The main question here might be how extremely differentiated sites compare to genomic regions of interest (either introgressed or not)

Might want to compare the levels between the Northern European population and the Southern European population, compared to NYC and California when I get that data.

```{r}
pi <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_pi.txt")
```

```{r}
pi %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi across whole genome") +
  theme_bw()
```


```{r}
dxy <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_dxy.txt")
```

```{r}
dxy %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_dxy, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Dxy across whole genome") +
  theme_bw()
```


```{r}
dxy[dxy$chromosome == "SCF_10",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_dxy, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Dxy across whole genome") +
  theme_bw()
```
```{r}
fst <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_fst.txt")
```

```{r}
fst[fst$chromosome == "SCF_10",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_wc_fst, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Fst across whole genome") +
  theme_bw()
```

Pixy Plot
```{r}

```

