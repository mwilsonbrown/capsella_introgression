---
title: "Capsella local ancestry introgression and PopGen"
author: "Maya Wilson Brown"
date: "2024-03-25"
output: html_document
---

##### Setup 
```{r libraries}
library(stringr)
library(dplyr)
library(ggplot2)
library(ggnewscale)
library(scico)
```


```{r sourcing functions}
source("~/Documents/PhD/Research/capsella_introgression/capsella_introgression_func.R")
```

# Introgression in Capsella bursa-pastoris

#### Data Preparation

```{r capsella sequenced information}
# load capsella whole genome sequencing information
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

```{r defined populations}
#load C. bursa-pastoris population information
k3pops <- read.csv("~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", header = T, sep = "\t")

# mutate another column that separates NY and NJ from the rest of the populations
ny_names <- wgs[which(wgs$citation == "R.Panko"),"vcf_sample_name"]

k3pops <- k3pops %>% mutate(k3pop_sm = case_when(vcf_sample_name %in% ny_names ~ "NYC",
                                                      .default = k3population))
```

# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern from viterbi output folder
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data; each sample gets its own list element df
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name

# produces list where each element is a df of the results for one sample
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit, idcol = "vcf_sample_name")
```

I will start by combining the viterbi decoding with the whole genome sequencing data

```{r}
# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, k3pops)

# order the scaffold levels
vit_all$chrom <- factor(vit_all$chrom, levels = paste0("jlSCF_", 9:16))
```
# Exploratory
The first thing I want to check is that the proportion of *C. rubella* ancestry is less than the proportion of *C. bursa-pastoris* ancestry.
```{r}
# proportion of local ancestry
colSums(vit_all[vit_all$ancestry == "rubella", "tract_length"])/colSums(vit_all[, "tract_length"])

# bursa-pastoris
colSums(vit_all[vit_all$ancestry == "bursa_pastoris", "tract_length"])/colSums(vit_all[, "tract_length"])

# heterozygous
colSums(vit_all[vit_all$ancestry == "heterozygous", "tract_length"])/colSums(vit_all[, "tract_length"])
```

Now, it might be interesting to look at the distributions of the tract lengths. I Expect them to be something close to a poisson distribution.
```{r}
# tract length distribution
tl_dist <- ggplot() + 
  geom_histogram(data=vit_all, aes(tract_length, fill=ancestry), bins = 40) +
  scale_fill_manual(values = anc.cols) +
  theme_bw() +
  facet_grid(chrom~ancestry, scales = "free") +
  theme(legend.position = "none")
tl_dist
ggsave(paste0(temp_plotdir, "tract_len.png"), tl_dist, width = 7, height = 5)
```
Most tracts are short, and bursa-pastoris tracts are on average, longer than others. Heterozygous tracts are the shortest.
# Introgression Plots

```{r nyc introgression plot}
# plot with funtion
ny_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "NYC")
ggsave(paste0(temp_plotdir, "ny_viterbi_SCF16_new.png"), ny_16, units = "in", height = 7, width = 12)

# plot with funtion
eu_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "N_Europe")
ggsave(paste0(temp_plotdir, "eu_viterbi_SCF16_new.png"), eu_16, units = "in", height = 7, width = 12)

# plot with funtion
mena_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "MENA")
ggsave(paste0(temp_plotdir, "mena_viterbi_SCF16_new.png"), mena_16, units = "in", height = 7, width = 12)

# plot with funtion
easian_16 <- viterbi_columns_plot(df = vit_all, scaffold_num = 16, population = "E_Asia")
ggsave(paste0(temp_plotdir, "easia_viterbi_SCF16_new.png"), easian_16, units = "in", height = 7, width = 12)
```


```{r nyc_introgression_plot_allScaffolds}
nyc_allc <- viterbi_columns_plot_allChr(vit_all, population = "NYC", facet.col = "#585380", facet.txt.col = "white")

ggsave(paste0(temp_plotdir,"ny_viterbi_all4.png"),nyc_allc, units = "in", height = 6, width = 14)
```

```{r nyc_introgression_plot_allScaffolds}
neu_allc <- viterbi_columns_plot_allChr(vit_all, population = "N_Europe" , facet.col = "#7FC55F", facet.txt.col = "black")

# why is the order wrong >:(
ggsave(paste0(temp_plotdir,"neu_viterbi_all4.png"),neu_allc, units = "in", height = 6, width = 10)
```

```{r nyc_introgression_plot_allScaffolds}
mena_allc <- viterbi_columns_plot_allChr(vit_all, population = "MENA", facet.col = "#996330", facet.txt.col = "white")

# why is the order wrong >:(
ggsave(paste0(temp_plotdir,"mena_viterbi_all4.png"),mena_allc, units = "in", height = 6, width = 6.7)
```

```{r nyc_introgression_plot_allScaffolds}
easia_allc <- viterbi_columns_plot_allChr(vit_all, population = c("E_Asia"))

ggsave(paste0(temp_plotdir,"easia_viterbi_all4.png"),easia_allc, units = "in", height = 5, width = 5)
```


Did not get the output I expected in that ther are some very small regions in the East Asian population that seem to have C. rubella ancestry.
```{r, eval=FALSE}
# load posterior for sample SRR6179241.sam (AQ415)
aq415 <- read.csv(paste0(ahmm_vit_path, "SRR6179241.sam.posterior"),
                  header = T, sep = "\t")

## have there always been very small regions shown as rubella in this population?
# list all files with matching pattern from viterbi output folder
tbl <- list.files(path = "~/Documents/PhD/Research/capsella_introgression/old_ahmm_output", pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data; each sample gets its own list element df
for (file in tbl) {
  file_path <- file.path("~/Documents/PhD/Research/capsella_introgression/old_ahmm_output", file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name

# add factors for ancestral state and add tract-length column
vit <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths

# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit, idcol = "vcf_sample_name")

# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, k3pops)

# order the scaffold levels
vit_all$chrom <- factor(vit_all$chrom, levels = paste0("jlSCF_", 9:16))

east_asian <- vit_all[which(vit_all$k3population == "E_Asia"),]

```



###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

Starting with the NYC samples
It may be possible to make a co-occurrence matrix with the bed output files.
```{r}
ny_rub_by_sample <- bed_by_sample(vit_all, anc = "rubella", population = "NYC", outdir = bed_files)
```

Now do the same for Mediterranean samples.

```{r mediterranenan samples, eval=FALSE}
mena_rub_by_sample <- bed_by_sample(vit_all, anc = "rubella",
                                  population = "MENA",
                                  outdir = bed_files)
```

And N. European samples
```{r write European to bed files}
# Warning: this function writes files automatically
eu_rub_by_sample <- bed_by_sample(vit_all, anc = "rubella",
                                  population = "N_Europe",
                                  outdir = bed_files)
```

### Introgressed region frequency
This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and **multi-inter** from BEDTools

```{bash, code = readLines("multiinter.sh")}
```

Let's take a look at the output
```{r}
# load multi inter output file
nyc_inter <- read.csv(paste0("~/Documents/PhD/Research/capsella_introgression/nyc_multiinter_rubella.txt"), header = T, sep = "\t")

# You can pass sample names to BEDtools but I will just fix them here
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "X") #remove directory info
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "_NYC_rubella.bed") #remove other info

# relevel factors
nyc_inter$chrom <- factor(nyc_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r NY Crubella chunks gradient}
# mistyrose = #FFE4E1, violetred4 = #8B2252
# gradient plot where darker colors mean more individuals share an introgressed chunk
# ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("New York introgressed region frequency") + theme_classic()

ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=start, xend=end, y=chrom, yend=chrom), linewidth = 10) + scale_y_discrete(labels = paste0("chr ", 9:16)) + scale_color_scico(palette = 'acton', direction = -1) + theme_classic() + labs(title = "New York introgressed region frequency", colour = "individuals", x = NULL, y = "position")

ggsave(paste0(temp_plotdir,"nyc_introgressed_freq.png"), units = "in", height = 6, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = nyc_inter[,1:4], binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```

Now again with the Mediterranean samples
```{r mediterranean, eval=FALSE}
# load file
mena_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/mena_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(mena_inter) <- str_remove(colnames(mena_inter), "X") #remove directory info
colnames(mena_inter) <- str_remove(colnames(mena_inter), "_MENA_rubella.bed") #remove other info

# relevel factors
mena_inter$chrom <- factor(mena_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r}

# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = mena_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + theme_classic() + scale_x_discrete(labels = paste0("chr ", 9:16)) + labs(title = "Middle East and Mediterranean introgressed region frequency", colour = "individuals", x = NULL, y = "position")

ggsave(paste0(temp_plotdir,"mena_introgressed_freq.png"), units = "in", height = 12, width = 12)
```
I will plot the N. European separately just for posterity but I am really more interested in the shared and private regions.

```{r mediterranean, eval=FALSE}
# load file
neu_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/neu_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(neu_inter) <- str_remove(colnames(neu_inter), "X") #remove directory info
colnames(neu_inter) <- str_remove(colnames(neu_inter), "_N_Europe_rubella.bed") #remove other info

# relevel factors
neu_inter$chrom <- factor(neu_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r}

# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = neu_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + theme_classic() + scale_x_discrete(labels = paste0("chr ", 9:16)) + labs(title = "N. Eurasian introgressed region frequency", colour = "individuals", x = NULL, y = "position")

ggsave(paste0(temp_plotdir,"neu_introgressed_freq.png"), units = "in", height = 12, width = 12)
```
##### MultiInter by K4 group
An easy way to figure out which regions are shared by all of the groups and private to each group is to do the multi-inter analysis on all of the capsella bursa-pastoris in the European lineage.

```{r}
# load file
all_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/all_multiinter_rubella.txt")

# You can pass sample names to BEDtools but I will just fix them here
colnames(all_inter) <- str_remove(colnames(all_inter), "X") #remove directory info

# column names to match individuals to numbers in small multi-inter df
all_names <- colnames(all_inter[6:length(colnames(all_inter))])

# save indices for each population
nyc_indx <- which(grepl( "NYC_rubella.bed", all_names, fixed = TRUE))
neu_indx <- which(grepl( "N_Europe_rubella.bed", all_names, fixed = TRUE))
mena_indx <- which(grepl( "MENA_rubella.bed", all_names, fixed = TRUE))
```

Now I would like to determine a series of tests

```{r}
# distribution of region sharing
ggplot() + geom_histogram(data = all_inter[,1:4], binwidth = 5, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
##### High Frequency shared regions
```{r}
#regions shared by all
all_inter[which(all_inter$num == 101), 1:4]
```


There is one 4000bp region on chromosome 12 that is shared by all the introgressed populations individuals. This region is know of note for population genetic studies as it should be pretty old to be shared among all.

It would be useful to be able to plot these things on top of one another
```{r}
#tuncate df
sm_all_inter <- all_inter[,1:5]

all_int_mat <- str_split_fixed(all_inter$list, ",", n=100)

#forcing matrix to numeric fills blanks with NA
class(all_int_mat) <- "numeric"

#combine
test <- cbind(sm_all_inter, data.frame(all_int_mat))

#pivot longer
test2 <- pivot_longer(test, cols = c(paste0("X", 1:100)), values_drop_na = T)

# check the last row of each segment is the same number as name?
```

Now to drop name column and assign population to each integer
```{r}
# drop name column
test2 <- subset(test2, select = -c(name, list))

# new column where indices indicate population
test3 <- test2 %>% mutate(population = case_when(value %in% nyc_indx ~ "NYC",
                                        value %in% neu_indx ~ "N. Europe",
                                        value %in% mena_indx ~ "MENA"))
```

Just working with one dataset at a time
```{r}
ggplot() + geom_linerange(data = test3, aes(x=population, ymin=start, ymax=end, color = num), linewidth = 5)+ coord_flip() + facet_wrap(~chrom, scales = "free", nrow = 8)

#ggsave("~/Desktop/test_plot1.png", width = 5, height = 11)
```

Once I have the above, then maybe I can split it into dataframes?
```{r}
test4 <- split(test3, test3$population)
```


```{r}
#withggnewscale
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + facet_wrap(~chrom, scales = "free", nrow = 8) + coord_flip() +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico("acton", direction=-1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = light.brown) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = greens)

ggsave("~/Desktop/test_plot2.png", width = 5, height = 11)
```
As mentioned above, it is actually more intuitive to me and beneficial to have each population on their own number scale. I will achieve that by joining the dfs?

```{r}
# add population indicators to all
nyc_inter$population <- "NYC metro"
neu_inter$population <- "N. Eurasia"
mena_inter$population <- "Med"

# combine the relevant part of the dfs
c_inter <- list(nyc_inter[,c("chrom","start","end","num","population")],neu_inter[,c("chrom","start","end","num","population")],mena_inter[,c("chrom","start","end","num","population")])
```

Attempt to generate plot?
```{r}
# make vector of pretty chromosome names
pretty_chrom <- paste0("Chr. ", 9:16)
names(pretty_chrom) <- paste0("jlSCF_", 9:16)
```

```{r}
#withggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + 
  facet_wrap(~chrom, scales = "free", nrow =2, ncol = 4,
             labeller = labeller(chrom = pretty_chrom)) + 
  coord_flip() +
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "right") + 
  labs(colour = "NYC Metro\nindividuals") +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() +
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  labs(colour = "N. Eurasia\nindividuals") +
  new_scale_color() + 
  labs(colour = "Mediterranean\nindividuals") +
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)

#ggsave("~/Desktop/introgression_plot_allscf_legend_side.png", width = 11, height = 5.5)
```
With different colors
```{r}
#withggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + 
  facet_wrap(~chrom, scales = "free", nrow =2, ncol = 4,
             labeller = labeller(chrom = pretty_chrom)) + 
  coord_flip() +
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "bottom") + 
  labs(colour = "NYC Metro\nindividuals") +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() +
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = greens) +
  labs(colour = "N. Eurasia\nindividuals") +
  new_scale_color() + 
  labs(colour = "Mediterranean\nindividuals") +
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = light.brown)

ggsave("~/Desktop/introgression_plot_allscf_legend_bottom_new_colors.png", width = 11, height = 5.5)
```



Attempt to indicate windows corresponding to Lostruct analysis
```{r}
# only scaffold 9 for now
c_inter[[4]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_9")
c_inter[[5]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_9")
c_inter[[6]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_9")

# only scaffold 10 for now
c_inter[[7]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_10")
c_inter[[8]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_10")
c_inter[[9]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_10")

# only scaffold 14
inter14 <- list()
inter14[[1]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_14")
inter14[[2]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_14")
inter14[[3]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_14")
```

```{r}
#withggnewscale and scico color pallets and windows indicated
ggplot() + theme_classic()+
  coord_flip() +
  geom_linerange(data = c_inter[[4]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[5]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[6]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1) +
  ggtitle("Scaffold 9")
#ggsave("~/Desktop/scaffold9_windows.png", width = 5, height = 5)
```
Now with windows in the plot

The way the Lostruct eigen windows function works is that the win argument considers a window to be consecutive rows of the given matrix. So it is calucating eigenvectors at each consecutive 3000 SNPs (in the case of Scaffold 9).

I want to align those SNP positions with BP positions for the plot above
```{r}
# Just generate df indicating window start and end row numbers
row_sind <- seq(from = 1, to = nrow(sc10), by = 1000)
row_eind <- c(seq(from = 1, to = nrow(sc10), by = 1000)-1)[2:length(row_sind)]
winds <- data.frame(start = row_sind[-38], end = row_eind) #rows for extracting bp positions from names

# from the row names, get the staring and ending bp positions
bp_ends <- as.numeric(str_remove(rownames(sc10)[winds$end], "jlSCF_10_"))
bp_beg <- as.numeric(str_remove(rownames(sc10)[winds$start], "jlSCF_10_"))

breaks <- data.frame(start = bp_beg, end = bp_ends)
```

```{r}
# adding geoms
base_med <- ggplot() + geom_rect(data = breaks,
            aes(ymin = start[3],
                ymax = end[3],
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "#a9ba9d") + 
  coord_flip() + 
  theme_classic() +
  geom_linerange(data = c_inter[[6]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)
```

Attemping with all populations
```{r}
# Scaffold 10 windows for examples
ggplot() + 
  coord_flip() + 
  theme_classic() +
  ggtitle("Chr. 10 Window 34") +
  theme(axis.text.x = element_text(size = 4), legend.position = "none") +
  geom_rect(data = breaks,
            aes(ymin = start[34],
                ymax = end[34],
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "lightgrey") +
  geom_linerange(data = c_inter[[7]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[8]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_gradientn(colors = greens) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[9]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_gradientn(colors = light.brown)

ggsave("~/Desktop/scaffold10_window34.png", width = 5, height = 2)
```
What about all of them?
```{r}
# adding geoms
ggplot() + 
  coord_flip() + 
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "none") +
  geom_rect(data = subset(seg_nyc_only, chrom == "jlSCF_14"),
            aes(ymin = start,
                ymax = end,
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "#a9ba9d") +
  geom_linerange(data = inter14[[1]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = inter14[[2]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = inter14[[3]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)
  
```

```{r}
# first, regions where any element of nyc is present and elements of mena and europe are not
nyc_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, nyc_indx)) >= 1, "in NYC", NA)
})
```
There is another group which I may be interested in, which is the NJ population by itself. That's population 24 and I can print the names to know they correspond to indices 43,44,45
```{r}
nj_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, 43:45)) >= 1, "in NJ", NA)
})
```

There is a more elegant way to do this (probably with casewhen) but I can fix that later. The plan is to get a vector of region status for each population
```{r}
# middle east and north africa
mena_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, mena_indx)) >= 1, "in MENA", NA)
})

# Europe
neu_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, neu_indx)) >= 1, "in N. Europe", NA)
})

# combine them
chunk_status <- data.frame(nyc_status,nj_status,mena_status,neu_status)

ind <- rowSums(is.na(chunk_status)) == ncol(chunk_status)
ind2 <- rowSums(is.na(all_stat[,6:8])) == ncol(all_stat[,6:8])
```

Bind with actual bed data and check which regions are in or out of each population
```{r}
all_stat <- cbind(all_inter[,1:5], chunk_status )
```

```{r}
# filter keeps rows that match a condition
# keep rows where europe and mena are NA (implying nyc is not, because I do not have empty regions)
seg_nyc_only <- all_stat %>%
   filter(if_all(c(mena_status,neu_status), is.na))

# present in NY/NJ and Europe; absent from MENA
seg_nyc_eu <- all_stat %>%
   filter(!(if_any(c(nyc_status, neu_status), is.na)) & is.na(mena_status))

# present in NY/NJ and MENA; absent from Europe
seg_nyc_mena <- all_stat %>%
   filter(!(if_any(c(nyc_status, mena_status), is.na)) & is.na(neu_status))

# present in NJ and Europe, which may drive the relationship between the two
seg_nj_neu <- all_stat %>%
   filter(!(if_any(c(nj_status, neu_status), is.na)) & is.na(mena_status))

# only in NJ (of which NY is inclusive)
#seg_nj <- all_stat %>%
   #filter(!is.na(nj_status) & if_all(c(neu_status, mena_status), is.na))

# private to NJ (not found elsewhere in NY)
seg_nj[which(seg_nj$num <= 3),]
```
There are `r nrow(seg_nyc_only)` introgressed regions only found in NYC, that have not been sampled in the MENA nor the N. European population.

There are introgressed regions that are only found in NJ and a sample in the Mediterranean population (namely KYRG-3-14, which is index 97 in this data): number = `r nrow(which(seg_nyc_mena$num ==4 & seg_nyc_mena$list == c(43,44,45,97)`

Visual inspection of the data shows there are only two regions that are in the N. European group and NJ and not in the rest of NYC, and those are two regions on scaffold 15
```{r}
seg_nj_neu[107:108,]

seg_nj_neu[107:108,"end"] - seg_nj_neu[107:108,"start"]
```
4k and 12k bp respectively.

Let's plot NYC only regions:
```{r}
nyc_private_hist <- ggplot() + geom_histogram(data = seg_nyc_only, aes(num)) +
  theme_classic() +
  xlab("individuals")

ggsave("~/Desktop/nyc_private_hist.png",nyc_private_hist, width = 5, height = 2)
```


```{r}
nyc_private_vio <- ggplot() + geom_boxplot(data = seg_nyc_only, aes(bp)) +
  theme_classic() +
  xlab("length (base pairs)")

ggsave("~/Desktop/nyc_private_boxplot.png",nyc_private_vio, width = 5, height = 2)
```

#### Pi in introgressed regions
To look at pairwise diversity in introgressed regions, first, I assigned individual Capsella bursa-pastoris to different populations where individuals are a part of 3 main lineages: Asian, with no introgression; Mediterranean, with introgression; and European/NewYorker, with introgression.

```{r}
# generating PIXY population file for input

# read in individuals list
allsites_inds <- read.csv("~/Documents/PhD/Research/capsella_introgression/allSites_inds.txt",
                          sep = "\t", header = F)

# join with vcf metadata
allsites_dat <- left_join(allsites_inds, k3pops, join_by("V1"=="vcf_sample_name"))

# invidiual missing from population file is WAC5 which is mediterranean.
allsites_dat[which(allsites_dat$V1 == "SRR6382401.sam"), c("sample_name", "k3population")] <- c("WAC5", "MENA")

# Then, just save as a headerless file with vcf sample names and population names
write.table(allsites_dat[c(1,3)],
            file = "~/Documents/PhD/Research/capsella_introgression/pixy_pops.txt",
            col.names = F,
            row.names = F,
            quote = F)

```


First, I looked at pairwise diversity in each population using sliding windows of 10,000 base pairs across the whole genome.

*ANOTHER THOUGHT*
Another analysis that may be interesting is to look at PI (pairwise diversity) along the genome within NYC populations to identify regions with higher or lower PI than expected?

But first, I am interested in Dxy comparing NYC regions to other.

The first thing I need to do is create a mapping list for Pixy defined populations for comparison.

The main question here might be how extremely differentiated sites compare to genomic regions of interest (either introgressed or not)

Might want to compare the levels between the Northern European population and the Southern European population, compared to NYC and California when I get that data.

```{r}
pi <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_pi.txt")
```

```{r}
pi %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi across whole genome") +
  theme_bw()
```


```{r}
dxy <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_dxy.txt")
```

```{r}
dxy %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_dxy, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Dxy across whole genome") +
  theme_bw()
```


```{r}
dxy[dxy$chromosome == "SCF_10",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_dxy, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Dxy across whole genome") +
  theme_bw()
```
```{r}
fst <- read.delim("~/Documents/PhD/Research/capsella_introgression/nyc_eurasia_k4_fst.txt")
```

```{r}
fst[fst$chromosome == "SCF_10",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_wc_fst, color = chromosome))+
  geom_line() +
  facet_grid(pop1~pop2) +
  ggtitle("Fst across whole genome") +
  theme_bw()
```

Pixy Plot
```{r}

```

#### Genic Content
We may be interested in comparing the number of genes in introgressed regions vs non-introgressed regions. To do this, we can use BEDTools intersect to see how many basepairs of genes from a Genome Feature File (GFF) intersect with basepairs from introgressed or non-introgressed regions.

I will create BEDfiles of non-intorgressed regions as before.
