---
title: "validation of Ancestry HMM using Lostruct"
author: "Maya Wilson Brown"
date: "2024-03-14"
output: html_document
---

Here, I will document a way that we validated that Ancestry HMM was pocking up on the kind of ancestry signals we expected.

We decided to use LOSTRUCT to look at a PCA at the locus level in our introgressed and non-introgressed loci of *Capsella bursa-pasoris*.


```{r load libraries}
# necessary libraries
library(SNPRelate)
#library(vcfR)
library(lostruct)
library(tidyverse)
```
Lostruct functions

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
  # x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x){
  #for each row, select all columns with PC1 in their name and store
  pc1_val <- x[which(grepl("PC_1", names(x[1:length(x)]), fixed = T))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_split_i(names(pc1_val), "_", -1)
  #and for PC2
  pc2_val <- x[which(grepl("PC_2", names(x[1:length(x)]), fixed = T))]
  #sample name
  sample_id2 <- str_split_i(names(pc2_val), "_", -1)

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, sample = sample_id)
  
  #change Monte Gargano sample name to be the full string
  win_pca[which(win_pca$sample == "Gargano"),"sample"] <- "Monte_Gargano"
  
  #create lgical vector matching sample names to species from Capsella list
  species <- Capsella_WGS_Sample_List$sample_name %in% win_pca$sample
  
  #create map for sampple name to species
  map <- unique(Capsella_WGS_Sample_List[species, c("sample_name","species")])
  
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, map, by = c("sample" = "sample_name"))
  #return the whole df
  return(df)
}
```


```{r directory variables}
post_dir = "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)
```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = post_dir, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(post_dir, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

Data cleaning and preparation.
```{r}
#remove the suffix from the list element names
names(dat) <- str_remove(names(dat), ".posterior")

# change the column names as well
```

To use lostruct, you need your data in a format with rows for each variant, and columns for each sample.

You can do this within the package if oyu have bcftools installed but I do not. :)

>The function eigen_windows() basically wants your data in a numeric matrix, with one row per variant and one column per sample (so that x[i,j] is the number of alleles that sample j has at site i). If your data are already in this form, then you can use it directly.

# Load VCF data
```{r load with VCFR, eval=FALSE}
# Get VCF file path
vcf_path <- "~/Documents/PhD/Research/CbpCr_Cbp_new_filtered.vcf.gz"
cbpcr <- read.vcfR(vcf_path, verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

```{r load with SNPRelate}
#open the GDS formatted file
(pruned_cbpcr.gsd <- snpgdsOpen("~/Documents/PhD/Research/old_local_ancestry_inference/ancestry_informative_sites/pruned_cbpcr.gds"))

#get SNP information
snplist <- snpgdsSNPList(pruned_cbpcr.gsd)

# extract numeric genotypes
snpr_genos <- snpgdsGetGeno(pruned_cbpcr.gsd, snpfirstdim = T)

# select sample IDs
meta <- snpgdsSummary(pruned_cbpcr.gsd)

#name the matrix columns with sample names
colnames(snpr_genos) <- meta[[1]]
```

```{r}
#compute local PCA coordinates
eigenstuff <- eigen_windows(snpr_genos, win=100, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca <- apply(eigenstuff, 1, reform_map)
```

### Assign windows to snpids
```{r}
wind <- rep(1:900, each = 100, length.out= nrow(snplist))

tail(wind)

snplist_wind <- cbind(wind, snplist)
``` 

```{r}
#compute local PCA coordinates; k is the number of PCs to return, win is number of windows to chop the genome into
eigenstuff <- eigen_windows(data=gt, win = 20, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

