---
title: "validation of Ancestry HMM using Lostruct"
author: "Maya Wilson Brown"
date: "2024-03-14"
output: html_document
---

Here, I will document a way that we validated that Ancestry HMM was pocking up on the kind of ancestry signals we expected.

We decided to use LOSTRUCT to look at a PCA at the locus level in our introgressed and non-introgressed loci of *Capsella bursa-pasoris*.

# Update: July 8, 2024
Updating Lostruct analysis with slightly different methods. 

```{r}
# load lostruct
library(lostruct)
library(vcfR)
```


~~Firstly, I converted my vcf to matrix format using **Medicago_VCF_recode.py** with Python2 and an uncompressed VCF.~~ This splits every genotype call into a column, so I end up with double the number of columns as samples.

```{r}
# just testing how I want to cod this on fake data
df <- j
```


```{r}
# load matrix format of VCF
# geno <- read.csv("~/Documents/PhD/Research/capsella_introgression/test_ahmm_vcf.output", sep = "\t", header = F, na.strings = ".") #recode dots as NA

cbpcr <- read.vcfR("~/Desktop/ahmm_pruned_all.vcf.gz", verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
#gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

First, calculate the SNP density along each chromosome to determine good window sizes.

I know from the viterbi introgression results that the minimum tract length of any ancestry is 1000 basepairs with a median of about 12k and mean of about 80k.

Given the length of each chromosome, windowing by minimum base pairs will give me about 18-48K windows per chromosome.
```{r}
# Chromosome lengths from VCF header
# bcftools view -h ahmm_pruned_all.vcf.gz | grep '##contig'

# chromosome lengths
chrom.lens <- c(jlSCF_10=18059344,
                jlSCF_11=18860713,
                jlSCF_12=16958022,
                jlSCF_13=14108429,
                jlSCF_14=27977798,
                jlSCF_15=22212120,
                jlSCF_16=17841782,
                jlSCF_9=43809629)
# select sites
chroms <- cbpcr[,1]

# sum sites on each chromosome
sum(chroms@fix[,"CHROM"]=="jlSCF_9")

# posit
snps <- data.frame(chroms@fix[,c("CHROM","POS")])

# turn to list
snp_ls <- split(snps, snps[1])

test<- snp_ls[[1]]
test$POS <- as.numeric(test$POS)

test2 <- test %>% mutate(dist_n = lead(POS) - lag(POS))

summary(test2$dist_n)

# average SNPs per chromosome
snps_c <- unlist(lapply(snp_ls, nrow))
```
Base pairs between SNPs is pretty variable, but it seems like 
Compute the eigenstructure for windows along the genome.

```{r}
#do the first 4 windows of 100 SNPs
# input matrix is just the VCF matrix without the first two columns (which are position names)

# to get a good value for win here, when out data has a row for each variant site, it would be useful to now aprroximately how many SNPs fall into each section before a switch between ancestry
eigenstuff <- eigen_windows(data = gt,
              win = 100,
              k=2)

pcs <- lostruct::eigen_windows(eigen_windows_matrix(gt), k=2)
```


#-----------------OLD CODE-----------------


```{r load libraries}
# necessary libraries
library(SNPRelate)
#library(vcfR)
library(lostruct)
library(tidyverse)
```
Lostruct functions

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
  # x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x){
  #for each row, select all columns with PC1 in their name and store
  pc1_val <- x[which(grepl("PC_1", names(x[1:length(x)]), fixed = T))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_split_i(names(pc1_val), "_", -1)
  #and for PC2
  pc2_val <- x[which(grepl("PC_2", names(x[1:length(x)]), fixed = T))]
  #sample name
  sample_id2 <- str_split_i(names(pc2_val), "_", -1)

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, sample = sample_id)
  
  #change Monte Gargano sample name to be the full string
  win_pca[which(win_pca$sample == "Gargano"),"sample"] <- "Monte_Gargano"
  
  #create lgical vector matching sample names to species from Capsella list
  species <- Capsella_WGS_Sample_List$sample_name %in% win_pca$sample
  
  #create map for sampple name to species
  map <- unique(Capsella_WGS_Sample_List[species, c("sample_name","species")])
  
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, map, by = c("sample" = "sample_name"))
  #return the whole df
  return(df)
}
```


```{r directory variables}
post_dir = "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)
```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = post_dir, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(post_dir, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

Data cleaning and preparation.
```{r}
#remove the suffix from the list element names
names(dat) <- str_remove(names(dat), ".posterior")

# change the column names as well
```

To use lostruct, you need your data in a format with rows for each variant, and columns for each sample.

You can do this within the package if oyu have bcftools installed but I do not. :)

,The function eigen_windows() basically wants your data in a numeric matrix, with one row per variant and one column per sample (so that x[i,j] is the number of alleles that sample j has at site i). If your data are already in this form, then you can use it directly.

# Load VCF data
```{r load with VCFR, eval=FALSE}
# Get VCF file path
vcf_path <- "~/Documents/PhD/Research/CbpCr_Cbp_new_filtered.vcf.gz"
cbpcr <- read.vcfR(vcf_path, verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

```{r load with SNPRelate}
#open the GDS formatted file
(pruned_cbpcr.gsd <- snpgdsOpen("~/Documents/PhD/Research/old_local_ancestry_inference/ancestry_informative_sites/pruned_cbpcr.gds"))

#get SNP information
snplist <- snpgdsSNPList(pruned_cbpcr.gsd)

# extract numeric genotypes
snpr_genos <- snpgdsGetGeno(pruned_cbpcr.gsd, snpfirstdim = T)

# select sample IDs
meta <- snpgdsSummary(pruned_cbpcr.gsd)

#name the matrix columns with sample names
colnames(snpr_genos) <- meta[[1]]
```

```{r}
#compute local PCA coordinates
eigenstuff <- eigen_windows(snpr_genos, win=100, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca <- apply(eigenstuff, 1, reform_map)
```

### Assign windows to snpids
```{r}
wind <- rep(1:900, each = 100, length.out= nrow(snplist))

tail(wind)

snplist_wind <- cbind(wind, snplist)
``` 

```{r}
#compute local PCA coordinates; k is the number of PCs to return, win is number of windows to chop the genome into
eigenstuff <- eigen_windows(data=gt, win = 20, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

