---
title: "Validation of Ancestry HMM using Lostruct"
author: "Maya Wilson Brown"
date: "2024-03-14"
output: html_document
---

Here, I will document a way that we validated that Ancestry HMM was pocking up on the kind of ancestry signals we expected.

We decided to use LOSTRUCT to look at a PCA at the locus level in our introgressed and non-introgressed loci of *Capsella bursa-pasoris*.

```{r}
# load lostruct
library(lostruct)
library(vcfR)
```

Loading sample data

```{r capsella sequenced information}
# load capsella whole genome sequencing information
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

```{r defined populations}
#load C. bursa-pastoris population information
k3pops <- read.csv("~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", header = T, sep = "\t")

# mutate another column that separates NY and NJ from the rest of the populations
ny_names <- wgs[which(wgs$citation == "R.Panko"),"vcf_sample_name"]

k3pops <- k3pops %>% mutate(k3pop_sm = case_when(vcf_sample_name %in% ny_names ~ "NYC",
                                                      .default = k3population))
```

### Introgressed region frequency
This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and **multi-inter** from BEDTools

```{bash, code = readLines("~/Documents/PhD/Research/capsella_introgression/multiinter.sh"), eval = FALSE}
```

Let's take a look at the output
```{r}
# load multi inter output file
nyc_inter <- read.csv(paste0("~/Documents/PhD/Research/capsella_introgression/nyc_multiinter_rubella.txt"), header = T, sep = "\t")

# You can pass sample names to BEDtools but I will just fix them here
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "X") #remove directory info
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "_NYC_rubella.bed") #remove other info

# relevel factors
nyc_inter$chrom <- factor(nyc_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r NY Crubella chunks gradient}
# mistyrose = #FFE4E1, violetred4 = #8B2252
# gradient plot where darker colors mean more individuals share an introgressed chunk
# ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("New York introgressed region frequency") + theme_classic()

ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=start, xend=end, y=chrom, yend=chrom), linewidth = 10) + scale_y_discrete(labels = paste0("chr ", 9:16)) + scale_color_scico(palette = 'acton', direction = -1) + theme_classic() + labs(title = "New York introgressed region frequency", colour = "individuals", x = NULL, y = "position")

ggsave(paste0(temp_plotdir,"nyc_introgressed_freq.png"), units = "in", height = 6, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = nyc_inter[,1:4], binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```

Now again with the Mediterranean samples
```{r mediterranean, eval=FALSE}
# load file
mena_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/mena_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(mena_inter) <- str_remove(colnames(mena_inter), "X") #remove directory info
colnames(mena_inter) <- str_remove(colnames(mena_inter), "_MENA_rubella.bed") #remove other info

# relevel factors
mena_inter$chrom <- factor(mena_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r}

# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = mena_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + theme_classic() + scale_x_discrete(labels = paste0("chr ", 9:16)) + labs(title = "Middle East and Mediterranean introgressed region frequency", colour = "individuals", x = NULL, y = "position")

ggsave(paste0(temp_plotdir,"mena_introgressed_freq.png"), units = "in", height = 12, width = 12)
```
I will plot the N. European separately just for posterity but I am really more interested in the shared and private regions.

```{r mediterranean, eval=FALSE}
# load file
neu_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/neu_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(neu_inter) <- str_remove(colnames(neu_inter), "X") #remove directory info
colnames(neu_inter) <- str_remove(colnames(neu_inter), "_N_Europe_rubella.bed") #remove other info

# relevel factors
neu_inter$chrom <- factor(neu_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r}

# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = neu_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + theme_classic() + scale_x_discrete(labels = paste0("chr ", 9:16)) + labs(title = "N. Eurasian introgressed region frequency", colour = "individuals", x = NULL, y = "position")

ggsave(paste0(temp_plotdir,"neu_introgressed_freq.png"), units = "in", height = 12, width = 12)
```
##### MultiInter by K4 group
An easy way to figure out which regions are shared by all of the groups and private to each group is to do the multi-inter analysis on all of the capsella bursa-pastoris in the European lineage.

```{r}
# load file
all_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/all_multiinter_rubella.txt")

# You can pass sample names to BEDtools but I will just fix them here
colnames(all_inter) <- str_remove(colnames(all_inter), "X") #remove directory info

# column names to match individuals to numbers in small multi-inter df
all_names <- colnames(all_inter[6:length(colnames(all_inter))])

# save indices for each population
nyc_indx <- which(grepl( "NYC_rubella.bed", all_names, fixed = TRUE))
neu_indx <- which(grepl( "N_Europe_rubella.bed", all_names, fixed = TRUE))
mena_indx <- which(grepl( "MENA_rubella.bed", all_names, fixed = TRUE))
```

Now I would like to determine a series of tests

```{r}
# distribution of region sharing
ggplot() + geom_histogram(data = all_inter[,1:4], binwidth = 5, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
##### High Frequency shared regions
```{r}
#regions shared by all
all_inter[which(all_inter$num == 101), 1:4]
```


There is one 4000bp region on chromosome 12 that is shared by all the introgressed populations individuals. This region is know of note for population genetic studies as it should be pretty old to be shared among all.

It would be useful to be able to plot these things on top of one another
```{r}
#tuncate df
sm_all_inter <- all_inter[,1:5]

all_int_mat <- str_split_fixed(all_inter$list, ",", n=100)

#forcing matrix to numeric fills blanks with NA
class(all_int_mat) <- "numeric"

#combine
test <- cbind(sm_all_inter, data.frame(all_int_mat))

#pivot longer
test2 <- pivot_longer(test, cols = c(paste0("X", 1:100)), values_drop_na = T)

# check the last row of each segment is the same number as name?
```

Now to drop name column and assign population to each integer
```{r}
# drop name column
test2 <- subset(test2, select = -c(name, list))

# new column where indices indicate population
test3 <- test2 %>% mutate(population = case_when(value %in% nyc_indx ~ "NYC",
                                        value %in% neu_indx ~ "N. Europe",
                                        value %in% mena_indx ~ "MENA"))
```

Just working with one dataset at a time
```{r}
ggplot() + geom_linerange(data = test3, aes(x=population, ymin=start, ymax=end, color = num), linewidth = 5)+ coord_flip() + facet_wrap(~chrom, scales = "free", nrow = 8)

#ggsave("~/Desktop/test_plot1.png", width = 5, height = 11)
```

Once I have the above, then maybe I can split it into dataframes?
```{r}
test4 <- split(test3, test3$population)
```


```{r}
#withggnewscale
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + facet_wrap(~chrom, scales = "free", nrow = 8) + coord_flip() +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico("acton", direction=-1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = light.brown) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = greens)

ggsave("~/Desktop/test_plot2.png", width = 5, height = 11)
```
As mentioned above, it is actually more intuitive to me and beneficial to have each population on their own number scale. I will achieve that by joining the dfs?

```{r}
# add population indicators to all
nyc_inter$population <- "NYC metro"
neu_inter$population <- "N. Eurasia"
mena_inter$population <- "Med"

# combine the relevant part of the dfs
c_inter <- list(nyc_inter[,c("chrom","start","end","num","population")],neu_inter[,c("chrom","start","end","num","population")],mena_inter[,c("chrom","start","end","num","population")])
```

Attempt to generate plot?
```{r}
# make vector of pretty chromosome names
pretty_chrom <- paste0("Chr. ", 9:16)
names(pretty_chrom) <- paste0("jlSCF_", 9:16)
```

```{r}
#withggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + 
  facet_wrap(~chrom, scales = "free", nrow =2, ncol = 4,
             labeller = labeller(chrom = pretty_chrom)) + 
  coord_flip() +
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "right") + 
  labs(colour = "NYC Metro\nindividuals") +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() +
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  labs(colour = "N. Eurasia\nindividuals") +
  new_scale_color() + 
  labs(colour = "Mediterranean\nindividuals") +
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)

#ggsave("~/Desktop/introgression_plot_allscf_legend_side.png", width = 11, height = 5.5)
```
With different colors
```{r}
#withggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + 
  facet_wrap(~chrom, scales = "free", nrow =2, ncol = 4,
             labeller = labeller(chrom = pretty_chrom)) + 
  coord_flip() +
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "bottom") + 
  labs(colour = "NYC Metro\nindividuals") +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() +
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = greens) +
  labs(colour = "N. Eurasia\nindividuals") +
  new_scale_color() + 
  labs(colour = "Mediterranean\nindividuals") +
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = light.brown)

ggsave("~/Desktop/introgression_plot_allscf_legend_bottom_new_colors.png", width = 11, height = 5.5)
```



Attempt to indicate windows corresponding to Lostruct analysis
```{r}
# only scaffold 9 for now
c_inter[[4]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_9")
c_inter[[5]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_9")
c_inter[[6]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_9")

# only scaffold 10 for now
c_inter[[7]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_10")
c_inter[[8]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_10")
c_inter[[9]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_10")

# only scaffold 14
inter14 <- list()
inter14[[1]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_14")
inter14[[2]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_14")
inter14[[3]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_14")
```

```{r}
#withggnewscale and scico color pallets and windows indicated
ggplot() + theme_classic()+
  coord_flip() +
  geom_linerange(data = c_inter[[4]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[5]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[6]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1) +
  ggtitle("Scaffold 9")
#ggsave("~/Desktop/scaffold9_windows.png", width = 5, height = 5)
```
Now with windows in the plot

The way the Lostruct eigen windows function works is that the win argument considers a window to be consecutive rows of the given matrix. So it is calucating eigenvectors at each consecutive 3000 SNPs (in the case of Scaffold 9).

I want to align those SNP positions with BP positions for the plot above
```{r}
# Just generate df indicating window start and end row numbers
row_sind <- seq(from = 1, to = nrow(sc10), by = 1000)
row_eind <- c(seq(from = 1, to = nrow(sc10), by = 1000)-1)[2:length(row_sind)]
winds <- data.frame(start = row_sind[-38], end = row_eind) #rows for extracting bp positions from names

# from the row names, get the staring and ending bp positions
bp_ends <- as.numeric(str_remove(rownames(sc10)[winds$end], "jlSCF_10_"))
bp_beg <- as.numeric(str_remove(rownames(sc10)[winds$start], "jlSCF_10_"))

breaks <- data.frame(start = bp_beg, end = bp_ends)
```

```{r}
# adding geoms
base_med <- ggplot() + geom_rect(data = breaks,
            aes(ymin = start[3],
                ymax = end[3],
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "#a9ba9d") + 
  coord_flip() + 
  theme_classic() +
  geom_linerange(data = c_inter[[6]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)
```

Attemping with all populations
```{r}
# Scaffold 10 windows for examples
ggplot() + 
  coord_flip() + 
  theme_classic() +
  ggtitle("Chr. 10 Window 34") +
  theme(axis.text.x = element_text(size = 4), legend.position = "none") +
  geom_rect(data = breaks,
            aes(ymin = start[34],
                ymax = end[34],
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "lightgrey") +
  geom_linerange(data = c_inter[[7]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[8]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_gradientn(colors = greens) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[9]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_gradientn(colors = light.brown)

ggsave("~/Desktop/scaffold10_window34.png", width = 5, height = 2)
```
What about all of them?
```{r}
# adding geoms
ggplot() + 
  coord_flip() + 
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "none") +
  geom_rect(data = subset(seg_nyc_only, chrom == "jlSCF_14"),
            aes(ymin = start,
                ymax = end,
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "#a9ba9d") +
  geom_linerange(data = inter14[[1]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = inter14[[2]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = inter14[[3]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)
  
```

```{r}
# first, regions where any element of nyc is present and elements of mena and europe are not
nyc_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, nyc_indx)) >= 1, "in NYC", NA)
})
```
There is another group which I may be interested in, which is the NJ population by itself. That's population 24 and I can print the names to know they correspond to indices 43,44,45
```{r}
nj_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, 43:45)) >= 1, "in NJ", NA)
})
```

There is a more elegant way to do this (probably with casewhen) but I can fix that later. The plan is to get a vector of region status for each population
```{r}
# middle east and north africa
mena_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, mena_indx)) >= 1, "in MENA", NA)
})

# Europe
neu_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, neu_indx)) >= 1, "in N. Europe", NA)
})

# combine them
chunk_status <- data.frame(nyc_status,nj_status,mena_status,neu_status)

ind <- rowSums(is.na(chunk_status)) == ncol(chunk_status)
ind2 <- rowSums(is.na(all_stat[,6:8])) == ncol(all_stat[,6:8])
```

Bind with actual bed data and check which regions are in or out of each population
```{r}
all_stat <- cbind(all_inter[,1:5], chunk_status )
```

```{r}
# filter keeps rows that match a condition
# keep rows where europe and mena are NA (implying nyc is not, because I do not have empty regions)
seg_nyc_only <- all_stat %>%
   filter(if_all(c(mena_status,neu_status), is.na))

# present in NY/NJ and Europe; absent from MENA
seg_nyc_eu <- all_stat %>%
   filter(!(if_any(c(nyc_status, neu_status), is.na)) & is.na(mena_status))

# present in NY/NJ and MENA; absent from Europe
seg_nyc_mena <- all_stat %>%
   filter(!(if_any(c(nyc_status, mena_status), is.na)) & is.na(neu_status))

# present in NJ and Europe, which may drive the relationship between the two
seg_nj_neu <- all_stat %>%
   filter(!(if_any(c(nj_status, neu_status), is.na)) & is.na(mena_status))

# only in NJ (of which NY is inclusive)
#seg_nj <- all_stat %>%
   #filter(!is.na(nj_status) & if_all(c(neu_status, mena_status), is.na))

# private to NJ (not found elsewhere in NY)
seg_nj[which(seg_nj$num <= 3),]
```
There are `r nrow(seg_nyc_only)` introgressed regions only found in NYC, that have not been sampled in the MENA nor the N. European population.

There are introgressed regions that are only found in NJ and a sample in the Mediterranean population (namely KYRG-3-14, which is index 97 in this data): number = `r nrow(which(seg_nyc_mena$num ==4 & seg_nyc_mena$list == c(43,44,45,97)`

Visual inspection of the data shows there are only two regions that are in the N. European group and NJ and not in the rest of NYC, and those are two regions on scaffold 15
```{r}
seg_nj_neu[107:108,]

seg_nj_neu[107:108,"end"] - seg_nj_neu[107:108,"start"]
```
4k and 12k bp respectively.

Let's plot NYC only regions:
```{r}
nyc_private_hist <- ggplot() + geom_histogram(data = seg_nyc_only, aes(num)) +
  theme_classic() +
  xlab("individuals")

ggsave("~/Desktop/nyc_private_hist.png",nyc_private_hist, width = 5, height = 2)
```


```{r}
nyc_private_vio <- ggplot() + geom_boxplot(data = seg_nyc_only, aes(bp)) +
  theme_classic() +
  xlab("length (base pairs)")

ggsave("~/Desktop/nyc_private_boxplot.png",nyc_private_vio, width = 5, height = 2)
```

Join and keep only necessary information
```{r}
# join vcf data and population output from capsella_population_def
sample_info <- left_join(wgs, k3pops)
```

```{r}
# load matrix format of VCF
# geno <- read.csv("~/Documents/PhD/Research/capsella_introgression/test_ahmm_vcf.output", sep = "\t", header = F, na.strings = ".") #recode dots as NA

cbpcr <- read.vcfR("~/Desktop/ahmm_pruned_capsella.vcf.gz", verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
#gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

First, calculate the SNP density along each chromosome to determine good window sizes.

I know from the viterbi introgression results that the minimum tract length of any ancestry is 1000 basepairs with a median of about 12k and mean of about 80k.

Given the length of each chromosome, windowing by minimum base pairs will give me about 18-48K windows per chromosome.
```{r}
# Chromosome lengths from VCF header
# bcftools view -h ahmm_pruned_all.vcf.gz | grep '##contig'

# chromosome lengths
chrom.lens <- c(jlSCF_10=18059344,
                jlSCF_11=18860713,
                jlSCF_12=16958022,
                jlSCF_13=14108429,
                jlSCF_14=27977798,
                jlSCF_15=22212120,
                jlSCF_16=17841782,
                jlSCF_9=43809629)
# select sites
chroms <- cbpcr[,1]

# sum sites on each chromosome
sum(chroms@fix[,"CHROM"]=="jlSCF_9")

# posit
snps <- data.frame(chroms@fix[,c("CHROM","POS")])

# turn to list
snp_ls <- split(snps, snps[1])

test<- snp_ls[[1]]
test$POS <- as.numeric(test$POS)

test2 <- test %>% mutate(dist_n = lead(POS) - lag(POS))

summary(test2$dist_n)

# average SNPs per chromosome
snps_c <- unlist(lapply(snp_ls, nrow))
```
Base pairs between SNPs is pretty variable, but it seems like 
Compute the eigenstructure for windows along the genome.

I am going to split the gt matrix into chromosomes, so that I can apply a windowing function to each chromosome separately.
```{r}
# splitting the gt matrix by chromomosome
sc9 <- gt[1:max(which(str_detect(rownames(gt), "jlSCF_9"))),] #scaffold 9
sc10 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_9")))):max(which(str_detect(rownames(gt), "jlSCF_10"))),] #scaffold 10
sc11 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_10")))):max(which(str_detect(rownames(gt), "jlSCF_11"))),] #scaffold 11
sc12 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_11")))):max(which(str_detect(rownames(gt), "jlSCF_12"))),] #scaffold 12

sc13 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_12")))):max(which(str_detect(rownames(gt), "jlSCF_13"))),] #scaffold 13
sc14 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_13")))):max(which(str_detect(rownames(gt), "jlSCF_14"))),] #scaffold 14
# remove chromosome from row name
rownames(sc14) <- as.numeric(str_remove(rownames(sc14), "jlSCF_14_"))

sc15 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_14")))):max(which(str_detect(rownames(gt), "jlSCF_15"))),] #scaffold 15
sc16 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_15")))):max(which(str_detect(rownames(gt), "jlSCF_16"))),] #scaffold 16
```

Fold all these into a list to make applying eigenwindows easier?
```{r}
scf_ls <- list(sc9,sc10,sc11,sc12,sc13,sc14,sc15,sc16)
```


```{r}
# calculate eigenvals and vecs for windows of size 3000 bp on scaffold 9
eigen9 <- lostruct::eigen_windows(data = sc9,
              win = 1000,
              k=2)
eigen10 <- lostruct::eigen_windows(data = sc10,
              win = 1000,
              k=2)

eigen14 <- lostruct::eigen_windows(data = sc14,
              win = 1000,
              k=2)
```

Testing with apply
```{r}
eigen_list <- lapply(scf_ls, lostruct::eigen_windows, win=3000, k=2)
```


You can use BCF tools to pull out windows useful with lostruct.


```{bash, code = readLines("~/Documents/PhD/Research/capsella_introgression/bed_extract_multiinter.sh"), eval = FALSE}
```


Load genotype matrix for only rubella regions
```{r}
nyc_rubella <- read.csv("~/Desktop/nyc_rubella_vcf.txt",
                        sep = "\t",
                        header = F)

# load sample names
samples <- scan("~/Desktop/nyc_rubella_vcf_samples.txt", character(), quote = "")

colnames(nyc_rubella) <- c("chrom", "pos", samples)

# split by chromosome
nyc_rubella_chr <- split(nyc_rubella[3:258], nyc_rubella[1])

# change to matrix
#test <- data.matrix(nyc_rubella[3:258])

# make all data tabled matrices
test2 <- lapply(nyc_rubella_chr, data.matrix)
```


Can I run lostruct on a handful of windows at a time?
```{r}
scf10_window100_bp <- lostruct::eigen_windows(data = test2[[1]],
              win = 100,
              k=2)

lpcascf10 <- apply(scf10_window100_bp, 1, reform_map, dat = scf10_window100_bp)

lpcascf10_long <- bind_rows(lpcascf10, .id = "window")

lpcascf10_long <- lpcascf10_long %>% mutate(across(c(k3population, k3pop_sm), ~ ifelse(is.na(.x), species, .x)))


lpcascf10_long$window <- factor(lpcascf10_long$window, levels = 1:length(unique(lpcascf10_long$window)))
```

```{r}
pc_plot1 <- ggplot() +
  geom_point(data=subset(lpcascf10_long, k3pop_sm != "Capsella bursa-pastoris"), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(values = species.cols)

pc_plot1
```

# Plots??
The first window of scaffold 9 should be C. rubella for all of the NYC individuals. I think?

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
# x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x, dat){
  #for each row, select all columns with PC1 in their name and store
  #pc1_val <- x[which(grepl("PC_1_", names(x[1:length(x)]), fixed = T))]
  pc1_val <- x[which(str_detect(colnames(dat), "PC_1_"))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_remove(names(pc1_val), "PC_1_")
  #and for PC2
  #pc2_val <- x[which(grepl("PC_2_", names(x[1:length(x)]), fixed = T))]
  pc2_val <- x[which(str_detect(colnames(dat), "PC_2_"))]
  #sample name
  sample_id2 <- str_remove(names(pc2_val), "PC_2_")

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, vcf_sample_name = sample_id)
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, sample_info)
  #return the whole df
  df2 <- df[,c("vcf_sample_name","PC1", "PC2", "species", "k3population", "k3pop_sm")]
  #return(df)
  return(df2)
}
```


Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca9 <- apply(eigen9, 1, reform_map, dat = eigen9)
```

Pivot longer to plot them all at once
```{r}
lpca9_long <- bind_rows(lpca9, .id = "window")
```

fill in NA for population
```{r}
# lpca9_long$k3population <- tidyr::replace_na(lpca9_long$k3population, "Other Sp.")
# lpca9_long$k3pop_sm <- tidyr::replace_na(lpca9_long$k3population, "Other Sp.")

lpca9_long <- lpca9_long %>% mutate(across(c(k3population, k3pop_sm), ~ ifelse(is.na(.x), species, .x)))
```

Make windows factors easily
```{r}
lpca9_long$window <- factor(lpca9_long$window, levels = 1:length(unique(lpca9_long$window)))
```

Plot please
```{r}
# species colors
#sp.cols <- c("Capsella bursa-pastoris = "#6D9636", rubella = "#FFCCFD", heterozygous = "#96938E")
```


```{r}
pc_plot1 <- ggplot() +
  geom_point(data=subset(lpca9_long, k3pop_sm != "Capsella bursa-pastoris"), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(values = species.cols)

pc_plot1

ggsave("lostruct_pca_scf9_transparent.png", pc_plot1, width = 10, height = 6, units = "in")
```


```{r}
pc_plot2 <- ggplot() +
  geom_point(data=lpca9[[2]], aes(x=PC1, y=PC2, color = species), size = 3) +
  theme_bw()

pc_plot2
```

```{r}
# apply data reformatting function to output
lpca10 <- apply(eigen10, 1, reform_map, dat = eigen10)
```

Pivot longer to plot them all at once
```{r}
lpca10_long <- bind_rows(lpca10, .id = "window")
```

fill in NA for population
```{r}
lpca10_long <- lpca10_long %>% mutate(across(c(k3population, k3pop_sm), ~ ifelse(is.na(.x), species, .x)))
```

Make windows factors easily
```{r}
lpca10_long$window <- factor(lpca10_long$window, levels = 1:length(unique(lpca10_long$window)))
```

```{r}
pc_plot1 <- ggplot() +
  geom_point(data=lpca10_long, aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(values = species.cols)

pc_plot1

#ggsave("lostruct_pca_scf10_transparent.png", pc_plot1, width = 10, height = 6, units = "in")
```
Single window at a time blown up
```{r}
sc10w34 <- ggplot() +
  geom_point(data=subset(lpca10_long, window == 34 & k3pop_sm != "Capsella bursa-pastoris"), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.7) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(name = "population", values = species.cols, labels = pop.labels) +
  theme(strip.background =element_rect(fill="lightgrey"),
        strip.text = element_text(size = 15))
sc10w34

ggsave("lostruct_pca_scf10_window34.png", sc10w34, width = 7, height = 5, units = "in")
```

```{r}
sc10w10 <- ggplot() +
  geom_point(data=subset(lpca10_long, window == 10 & k3pop_sm != "Capsella bursa-pastoris"), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.7) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(name = "population", values = species.cols, labels = pop.labels) +
  theme(strip.background =element_rect(fill="lightgrey"),
        strip.text = element_text(size = 15))

sc10w10

ggsave("lostruct_pca_scf10_window10.png", sc10w10, width = 7, height = 5, units = "in")
```

```{r}
sc10w12 <- ggplot() +
  geom_point(data=subset(lpca10_long, window == 12
                         ), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  theme_classic() + facet_wrap(~window)

ggsave("lostruct_pca_scf10_window12.png", sc10w12, width = 10, height = 6, units = "in")
```

Scaffold 14
For an example of NYC CBP alone

Prep the data

```{r}
# apply data reformatting function to output
lpca14 <- apply(eigen14, 1, reform_map, dat = eigen14)
```

Pivot longer to plot them all at once
```{r}
lpca14_long <- bind_rows(lpca14, .id = "window")
```

fill in NA for population
```{r}
lpca14_long <- lpca14_long %>% mutate(across(c(k3population, k3pop_sm), ~ ifelse(is.na(.x), species, .x)))
```

Make windows factors easily
```{r}
lpca14_long$window <- factor(lpca14_long$window, levels = 1:length(unique(lpca14_long$window)))
```

```{r}
plt <- ggplot() +
  geom_point(data=lpca14_long, aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(values = species.cols)

plt

ggsave("lostruct_pca_scf14_transparent.png", plt, width = 10, height = 6, units = "in")
```

#-----------------OLD CODE-----------------


```{r load libraries}
# necessary libraries
library(SNPRelate)
#library(vcfR)
library(lostruct)
library(tidyverse)
```
Lostruct functions

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
  # x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x){
  #for each row, select all columns with PC1 in their name and store
  pc1_val <- x[which(grepl("PC_1", names(x[1:length(x)]), fixed = T))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_split_i(names(pc1_val), "_", -1)
  #and for PC2
  pc2_val <- x[which(grepl("PC_2", names(x[1:length(x)]), fixed = T))]
  #sample name
  sample_id2 <- str_split_i(names(pc2_val), "_", -1)

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, sample = sample_id)
  
  #change Monte Gargano sample name to be the full string
  win_pca[which(win_pca$sample == "Gargano"),"sample"] <- "Monte_Gargano"
  
  #create lgical vector matching sample names to species from Capsella list
  species <- Capsella_WGS_Sample_List$sample_name %in% win_pca$sample
  
  #create map for sampple name to species
  map <- unique(Capsella_WGS_Sample_List[species, c("sample_name","species")])
  
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, map, by = c("sample" = "sample_name"))
  #return the whole df
  return(df)
}
```


```{r directory variables}
post_dir = "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)
```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = post_dir, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(post_dir, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

Data cleaning and preparation.
```{r}
#remove the suffix from the list element names
names(dat) <- str_remove(names(dat), ".posterior")

# change the column names as well
```

To use lostruct, you need your data in a format with rows for each variant, and columns for each sample.

You can do this within the package if oyu have bcftools installed but I do not. :)

,The function eigen_windows() basically wants your data in a numeric matrix, with one row per variant and one column per sample (so that x[i,j] is the number of alleles that sample j has at site i). If your data are already in this form, then you can use it directly.

# Load VCF data
```{r load with VCFR, eval=FALSE}
# Get VCF file path
vcf_path <- "~/Documents/PhD/Research/CbpCr_Cbp_new_filtered.vcf.gz"
cbpcr <- read.vcfR(vcf_path, verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

```{r load with SNPRelate}
#open the GDS formatted file
(pruned_cbpcr.gsd <- snpgdsOpen("~/Documents/PhD/Research/old_local_ancestry_inference/ancestry_informative_sites/pruned_cbpcr.gds"))

#get SNP information
snplist <- snpgdsSNPList(pruned_cbpcr.gsd)

# extract numeric genotypes
snpr_genos <- snpgdsGetGeno(pruned_cbpcr.gsd, snpfirstdim = T)

# select sample IDs
meta <- snpgdsSummary(pruned_cbpcr.gsd)

#name the matrix columns with sample names
colnames(snpr_genos) <- meta[[1]]
```

```{r}
#compute local PCA coordinates
eigenstuff <- eigen_windows(snpr_genos, win=100, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca <- apply(eigenstuff, 1, reform_map)
```

### Assign windows to snpids
```{r}
wind <- rep(1:900, each = 100, length.out= nrow(snplist))

tail(wind)

snplist_wind <- cbind(wind, snplist)
``` 

```{r}
#compute local PCA coordinates; k is the number of PCs to return, win is number of windows to chop the genome into
eigenstuff <- eigen_windows(data=gt, win = 20, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

