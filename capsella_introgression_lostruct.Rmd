---
title: "Validation of Ancestry HMM using Lostruct"
author: "Maya Wilson Brown"
date: "2024-03-14"
output: html_document
---

Here, I will document a way that we validated that Ancestry HMM was pocking up on the kind of ancestry signals we expected.

We decided to use LOSTRUCT to look at a PCA at the locus level in our introgressed and non-introgressed loci of *Capsella bursa-pasoris*.

```{r load libraries}
# load libraries
library(lostruct)
library(vcfR)
library(tidyr)
library(stringr)
library(dplyr)
# for plotting
library(ggplot2)
library(scico)
library(ggnewscale)
```

```{r sourcing functions}
source("~/Documents/PhD/Research/capsella_introgression/capsella_introgression_func.R")
```

Loading sample data

```{r capsella sequenced information}
# load capsella whole genome sequencing information
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

```{r defined populations}
#load C. bursa-pastoris population information
k3pops <- read.csv("~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", header = T, sep = "\t")

# mutate another column that separates NY and NJ from the rest of the populations
ny_names <- wgs[which(wgs$citation == "R.Panko"),"vcf_sample_name"]

k3pops <- k3pops %>% mutate(k3pop_sm = case_when(vcf_sample_name %in% ny_names ~ "NYC",
                                                      .default = k3population))
```

### Introgressed region frequency
This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and **multi-inter** from BEDTools

```{bash bedtools multiinter script, code = readLines("~/Documents/PhD/Research/capsella_introgression/multiinter.sh"), eval = FALSE}
```

Let's take a look at the output
```{r NYC multiiinter data}
# load multi inter output file
nyc_inter <- read.csv(paste0("~/Documents/PhD/Research/capsella_introgression/nyc_multiinter_rubella.txt"), header = T, sep = "\t")

# You can pass sample names to BEDtools but I will just fix them here
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "X") #remove directory info
colnames(nyc_inter) <- str_remove(colnames(nyc_inter), "_NYC_rubella.bed") #remove other info

# relevel factors
nyc_inter$chrom <- factor(nyc_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r NYC introgressed region frequency}
ggplot() + geom_segment(data = nyc_inter[,1:4], aes(colour= num, x=start, xend=end, y=chrom, yend=chrom), linewidth = 10) + scale_y_discrete(labels = paste0("chr ", 9:16)) + scale_color_scico(palette = 'acton', direction = -1) + theme_classic() + labs(title = "New York introgressed region frequency", colour = "individuals", x = NULL, y = "position")
```

```{r}
ggsave(paste0(plot_dir,"nyc_introgressed_freq.png"), units = "in", height = 6, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r distribution of shared regions in NYC}
ggplot() + geom_histogram(data = nyc_inter[,1:4], binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```

Now again with the Mediterranean samples
```{r mediterranean multiinter data}
# load file
mena_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/mena_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(mena_inter) <- str_remove(colnames(mena_inter), "X") #remove directory info
colnames(mena_inter) <- str_remove(colnames(mena_inter), "_MENA_rubella.bed") #remove other info

# relevel factors
mena_inter$chrom <- factor(mena_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r Mediterranean introgressed region frequency}
# same plot as NYC but portrait orientation
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = mena_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "#330000", low = "#f3cea9") + theme_classic() + scale_x_discrete(labels = paste0("chr ", 9:16)) + labs(title = "Middle East and Mediterranean introgressed region frequency", colour = "individuals", x = NULL, y = "position")
```

```{r}
ggsave(paste0(plot_dir,"mena_introgressed_freq.png"), units = "in", height = 12, width = 6)
```
I will plot the N. European separately just for posterity but I am really more interested in the shared and private regions.

```{r N. Eurasian multiinter data}
# load file
neu_inter <- read.delim("~/Documents/PhD/Research/capsella_introgression/neu_multiinter_rubella.txt")
# You can pass sample names to BEDtools but I will just fix them here
colnames(neu_inter) <- str_remove(colnames(neu_inter), "X") #remove directory info
colnames(neu_inter) <- str_remove(colnames(neu_inter), "_N_Europe_rubella.bed") #remove other info

# relevel factors
neu_inter$chrom <- factor(neu_inter$chrom, levels = paste0("jlSCF_", 9:16))
```

```{r}
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = neu_inter[,1:4], aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "#002C00", low = "#E5FFC5") + theme_classic() + scale_x_discrete(labels = paste0("chr ", 9:16)) + labs(title = "N. Eurasian introgressed region frequency", colour = "individuals", x = NULL, y = "position")
```

```{r}
ggsave(paste0(plot_dir,"neu_introgressed_freq.png"), units = "in", height = 12, width = 6)
```

As mentioned above, it is actually more intuitive to me and beneficial to have each population on their own number scale. I will achieve that by joining the dfs?

```{r}
# add population indicators to all
nyc_inter$population <- "NYC metro"
neu_inter$population <- "N. Eurasia"
mena_inter$population <- "Med"

# combine the relevant part of the dfs
c_inter <- list(nyc_inter[,c("chrom","start","end","num","population")],neu_inter[,c("chrom","start","end","num","population")],mena_inter[,c("chrom","start","end","num","population")])
```

Attempt to generate plot
```{r}
# make vector of pretty chromosome names
pretty_chrom <- paste0("Chr. ", 9:16)
names(pretty_chrom) <- paste0("jlSCF_", 9:16)
```


```{r}
# with ggnewscale and scico color pallets
ggplot(mapping = aes(x=population, ymin=start, ymax=end)) + 
  facet_wrap(~chrom, scales = "free", nrow =2, ncol = 4,
             labeller = labeller(chrom = pretty_chrom)) + 
  coord_flip() +
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "bottom") + 
  labs(colour = "NYC Metro\nindividuals") +
  geom_linerange(data = c_inter[[1]], linewidth = 5, aes(color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() +
  geom_linerange(data = c_inter[[2]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = greens) +
  labs(colour = "N. Eurasia\nindividuals") +
  new_scale_color() + 
  labs(colour = "Mediterranean\nindividuals") +
  geom_linerange(data = c_inter[[3]], linewidth = 5, aes(color = num)) +
  scale_color_gradientn(colors = light.brown)
```

```{r}
ggsave(paste0(plot_dir, "introgression_plot_allscf.png"), width = 11, height = 5.5)
```


#### Evaluating introgressed regions with LOSTRUCT
The new goal here, is do have the LOSTRUCT windows to be based on genomic regions determined by introgression or not.

You can use BCF tools to pull out windows useful with lostruct.
```{bash, code = readLines("~/Documents/PhD/Research/capsella_introgression/bed_extract_multiinter.sh"), eval = FALSE}
```

Load genotype matrix for only rubella regions
```{r}
# load numeric genotype matrix from bed_extract_multiinter.sh
nyc_rubella <- read.csv("~/Desktop/nyc_rubella_vcf.txt",
                        sep = "\t",
                        header = F)

# load sample names; sample names aquired from bcftools query -l without Neslia paniculata sample
samples <- scan("~/Desktop/nyc_rubella_vcf_samples.txt", character(), quote = "")

# assign sample names to columns
colnames(nyc_rubella) <- c("chrom", "pos", samples)

# assign variant ids to rownames
rownames(nyc_rubella) <- paste(nyc_rubella$chrom, nyc_rubella$pos, sep = ":")

# split by chromosome
nyc_rubella_chr <- split(nyc_rubella[3:258], nyc_rubella[1])

# change to matrix
#test <- data.matrix(nyc_rubella[3:258])

# make all data tabled matrices
genomat <- lapply(nyc_rubella_chr, data.matrix)
```

I can either pass the numeric matrix directly to eigen_windows or write a window extraction function that returns the numeric matrix of a specific window. I will try to write a window extractor function.

The arguments of the function have to take a numeric integer, n, to select the window of interest. So, basically, I need to figure out the starting and stopping SNPs for

My first idea is to assign a window ID to any location where the last bp of the previous row in the multiinter BED is not the same at the first bp of the next row, indicating a gap.

Just work with Scaffold 10 for the time being.
```{r, eval = F}
# scaffold 10 matrix
scf10m <- genomat[[1]]

# grab rownames and drop the scaffold indicator
rnames <- as.integer(str_remove_all(rownames(scf10m), paste0("jlSCF_", "10", ":")))

gaps <- lead(rnames, n=1) - lag(rnames, n=1)

# find positions where theres a large gap between SNPs (10,000bp)
rnames[which(gaps > 10000)-1]
```
Kind of silly to write my own window extractor function when all of the SNPs in the matrix fall within regions that have at least one individual. So at this point, I will just make windows of about 100 SNPs. Then, for a comparison of regions without introgression, I will use BED files from the *C. bursa-pastoris* inferred regions.

```{r calculate eigens for windows on scaffold 10}
# ON scaffold 10, extract windows of 100 continuous SNPs (rows of matrix)
s10_100snp <- lostruct::eigen_windows(data = genomat[["jlSCF_10"]],
              win = 100,
              k=2)
```


```{r reformat eigeninfo for scaffold 10}
# apply reformatting function to each row of output matrix
pca10 <- apply(s10_100snp, 1, reform_map, dat = s10_100snp)

# unroll list into long data frame
pca10_long <- bind_rows(pca10, .id = "window")

# if no population information present, fill population columns with species
pca10_long <- pca10_long %>% mutate(across(c(k3population, k3pop_sm), ~ ifelse(is.na(.x), species, .x)))

# make the windows a factor
pca10_long$window <- factor(pca10_long$window, levels = 1:length(unique(pca10_long$window)))
```

# Plots
```{r}
pc_plot1 <- ggplot() +
  geom_point(data=subset(pca10_long, k3pop_sm != "Capsella bursa-pastoris" & window %in% as.character(1:20)), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(values = species.cols)

pc_plot1
```
```{r}
ggsave(paste0(plot_dir, "lostruct_pca_scf10_w1-20.png"), pc_plot1, width = 10, height = 6, units = "in")
```

Single window at a time blown up
```{r}
sc10w34 <- ggplot() +
  geom_point(data=subset(pca10_long, window == 34 & k3pop_sm != "Capsella bursa-pastoris"), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.7) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(name = "population", values = species.cols, labels = pop.labels) +
  theme(strip.background =element_rect(fill="lightgrey"),
        strip.text = element_text(size = 15))
sc10w34
```

```{r}
ggsave(paste0(plot_dir,"lostruct_pca_scf10_window34.png"), sc10w34, width = 7, height = 5, units = "in")
```

```{r}
sc10w10 <- ggplot() +
  geom_point(data=subset(lpca10_long, window == 10 & k3pop_sm != "Capsella bursa-pastoris"), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.7) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(name = "population", values = species.cols, labels = pop.labels) +
  theme(strip.background =element_rect(fill="lightgrey"),
        strip.text = element_text(size = 15))

sc10w10

ggsave("lostruct_pca_scf10_window10.png", sc10w10, width = 7, height = 5, units = "in")
```

```{r}
sc10w12 <- ggplot() +
  geom_point(data=subset(lpca10_long, window == 12
                         ), aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  theme_classic() + facet_wrap(~window)

ggsave("lostruct_pca_scf10_window12.png", sc10w12, width = 10, height = 6, units = "in")
```

Scaffold 14
For an example of NYC CBP alone

Prep the data

```{r}
# apply data reformatting function to output
lpca14 <- apply(eigen14, 1, reform_map, dat = eigen14)
```

Pivot longer to plot them all at once
```{r}
lpca14_long <- bind_rows(lpca14, .id = "window")
```

fill in NA for population
```{r}
lpca14_long <- lpca14_long %>% mutate(across(c(k3population, k3pop_sm), ~ ifelse(is.na(.x), species, .x)))
```

Make windows factors easily
```{r}
lpca14_long$window <- factor(lpca14_long$window, levels = 1:length(unique(lpca14_long$window)))
```

```{r}
plt <- ggplot() +
  geom_point(data=lpca14_long, aes(x=PC1, y=PC2, color = k3pop_sm, shape= species), size = 3, alpha = 0.5) +
  scale_shape_manual(values = c('Capsella\ grandiflora'=15, 'Capsella\ orientalis'=18, 'Capsella\ bursa-pastoris'=16, 'Capsella\ rubella'=17)) + 
  theme_classic() + facet_wrap(~window) + scale_color_manual(values = species.cols)

plt

ggsave("lostruct_pca_scf14_transparent.png", plt, width = 10, height = 6, units = "in")
```
### Joining plots

Attempt to indicate windows corresponding to Lostruct analysis
```{r}
# only scaffold 9 for now
c_inter[[4]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_9")
c_inter[[5]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_9")
c_inter[[6]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_9")

# only scaffold 10 for now
c_inter[[7]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_10")
c_inter[[8]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_10")
c_inter[[9]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_10")

# only scaffold 14
inter14 <- list()
inter14[[1]] <- c_inter[[1]] %>% filter(chrom == "jlSCF_14")
inter14[[2]] <- c_inter[[2]] %>% filter(chrom == "jlSCF_14")
inter14[[3]] <- c_inter[[3]] %>% filter(chrom == "jlSCF_14")
```

```{r}
#withggnewscale and scico color pallets and windows indicated
ggplot() + theme_classic()+
  coord_flip() +
  geom_linerange(data = c_inter[[4]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[5]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[6]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1) +
  ggtitle("Scaffold 9")
#ggsave("~/Desktop/scaffold9_windows.png", width = 5, height = 5)
```
Now with windows in the plot

The way the Lostruct eigen windows function works is that the win argument considers a window to be consecutive rows of the given matrix. So it is calucating eigenvectors at each consecutive 3000 SNPs (in the case of Scaffold 9).

I want to align those SNP positions with BP positions for the plot above
```{r}
# Just generate df indicating window start and end row numbers
row_sind <- seq(from = 1, to = nrow(sc10), by = 1000)
row_eind <- c(seq(from = 1, to = nrow(sc10), by = 1000)-1)[2:length(row_sind)]
winds <- data.frame(start = row_sind[-38], end = row_eind) #rows for extracting bp positions from names

# from the row names, get the staring and ending bp positions
bp_ends <- as.numeric(str_remove(rownames(sc10)[winds$end], "jlSCF_10_"))
bp_beg <- as.numeric(str_remove(rownames(sc10)[winds$start], "jlSCF_10_"))

breaks <- data.frame(start = bp_beg, end = bp_ends)
```

```{r}
# adding geoms
base_med <- ggplot() + geom_rect(data = breaks,
            aes(ymin = start[3],
                ymax = end[3],
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "#a9ba9d") + 
  coord_flip() + 
  theme_classic() +
  geom_linerange(data = c_inter[[6]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)
```

Attemping with all populations
```{r}
# Scaffold 10 windows for examples
ggplot() + 
  coord_flip() + 
  theme_classic() +
  ggtitle("Chr. 10 Window 34") +
  theme(axis.text.x = element_text(size = 4), legend.position = "none") +
  geom_rect(data = breaks,
            aes(ymin = start[34],
                ymax = end[34],
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "lightgrey") +
  geom_linerange(data = c_inter[[7]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'acton', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[8]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_gradientn(colors = greens) +
  new_scale_color() + 
  geom_linerange(data = c_inter[[9]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_gradientn(colors = light.brown)

ggsave("~/Desktop/scaffold10_window34.png", width = 5, height = 2)
```
What about all of them?
```{r}
# adding geoms
ggplot() + 
  coord_flip() + 
  theme_classic() +
  theme(axis.text.x = element_text(size = 4), legend.position = "none") +
  geom_rect(data = subset(seg_nyc_only, chrom == "jlSCF_14"),
            aes(ymin = start,
                ymax = end,
                xmin = - Inf,
                xmax = Inf),
            alpha = 0.5,
            fill = "#a9ba9d") +
  geom_linerange(data = inter14[[1]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lapaz', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = inter14[[2]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'bamako', direction = -1) +
  new_scale_color() + 
  geom_linerange(data = inter14[[3]], linewidth = 5, aes(x=population, ymin=start, ymax=end, color = num)) +
  scale_color_scico(palette = 'lajolla', direction = -1)
  
```

```{r}
# first, regions where any element of nyc is present and elements of mena and europe are not
nyc_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, nyc_indx)) >= 1, "in NYC", NA)
})
```
There is another group which I may be interested in, which is the NJ population by itself. That's population 24 and I can print the names to know they correspond to indices 43,44,45
```{r}
nj_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, 43:45)) >= 1, "in NJ", NA)
})
```

There is a more elegant way to do this (probably with casewhen) but I can fix that later. The plan is to get a vector of region status for each population
```{r}
# middle east and north africa
mena_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, mena_indx)) >= 1, "in MENA", NA)
})

# Europe
neu_status <- apply(all_inter["list"], 1, function(x){
# for each row, take the value of column 'list' and make it a vector and split elements into characters
el <- str_split_1(x, ",")
# make the character vector numeric
nel <- as.numeric(el)
# check if the region is private to a group
ifelse(sum(intersect(nel, neu_indx)) >= 1, "in N. Europe", NA)
})

# combine them
chunk_status <- data.frame(nyc_status,nj_status,mena_status,neu_status)

ind <- rowSums(is.na(chunk_status)) == ncol(chunk_status)
ind2 <- rowSums(is.na(all_stat[,6:8])) == ncol(all_stat[,6:8])
```

Bind with actual bed data and check which regions are in or out of each population
```{r}
all_stat <- cbind(all_inter[,1:5], chunk_status )
```

```{r}
# filter keeps rows that match a condition
# keep rows where europe and mena are NA (implying nyc is not, because I do not have empty regions)
seg_nyc_only <- all_stat %>%
   filter(if_all(c(mena_status,neu_status), is.na))

# present in NY/NJ and Europe; absent from MENA
seg_nyc_eu <- all_stat %>%
   filter(!(if_any(c(nyc_status, neu_status), is.na)) & is.na(mena_status))

# present in NY/NJ and MENA; absent from Europe
seg_nyc_mena <- all_stat %>%
   filter(!(if_any(c(nyc_status, mena_status), is.na)) & is.na(neu_status))

# present in NJ and Europe, which may drive the relationship between the two
seg_nj_neu <- all_stat %>%
   filter(!(if_any(c(nj_status, neu_status), is.na)) & is.na(mena_status))

# only in NJ (of which NY is inclusive)
#seg_nj <- all_stat %>%
   #filter(!is.na(nj_status) & if_all(c(neu_status, mena_status), is.na))

# private to NJ (not found elsewhere in NY)
seg_nj[which(seg_nj$num <= 3),]
```
There are `r nrow(seg_nyc_only)` introgressed regions only found in NYC, that have not been sampled in the MENA nor the N. European population.

There are introgressed regions that are only found in NJ and a sample in the Mediterranean population (namely KYRG-3-14, which is index 97 in this data): number = `r nrow(which(seg_nyc_mena$num ==4 & seg_nyc_mena$list == c(43,44,45,97)`

Visual inspection of the data shows there are only two regions that are in the N. European group and NJ and not in the rest of NYC, and those are two regions on scaffold 15
```{r}
seg_nj_neu[107:108,]

seg_nj_neu[107:108,"end"] - seg_nj_neu[107:108,"start"]
```
4k and 12k bp respectively.

Let's plot NYC only regions:
```{r}
nyc_private_hist <- ggplot() + geom_histogram(data = seg_nyc_only, aes(num)) +
  theme_classic() +
  xlab("individuals")

ggsave("~/Desktop/nyc_private_hist.png",nyc_private_hist, width = 5, height = 2)
```


```{r}
nyc_private_vio <- ggplot() + geom_boxplot(data = seg_nyc_only, aes(bp)) +
  theme_classic() +
  xlab("length (base pairs)")

ggsave("~/Desktop/nyc_private_boxplot.png",nyc_private_vio, width = 5, height = 2)
```

Join and keep only necessary information
```{r}
# join vcf data and population output from capsella_population_def
sample_info <- left_join(wgs, k3pops)
```

```{r}
# load matrix format of VCF
# geno <- read.csv("~/Documents/PhD/Research/capsella_introgression/test_ahmm_vcf.output", sep = "\t", header = F, na.strings = ".") #recode dots as NA

cbpcr <- read.vcfR("~/Desktop/ahmm_pruned_capsella.vcf.gz", verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
#gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```


#-----------------OLD CODE-----------------


```{r load libraries}
# necessary libraries
library(SNPRelate)
#library(vcfR)
library(lostruct)
library(tidyverse)
```
Lostruct functions

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
  # x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x){
  #for each row, select all columns with PC1 in their name and store
  pc1_val <- x[which(grepl("PC_1", names(x[1:length(x)]), fixed = T))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_split_i(names(pc1_val), "_", -1)
  #and for PC2
  pc2_val <- x[which(grepl("PC_2", names(x[1:length(x)]), fixed = T))]
  #sample name
  sample_id2 <- str_split_i(names(pc2_val), "_", -1)

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, sample = sample_id)
  
  #change Monte Gargano sample name to be the full string
  win_pca[which(win_pca$sample == "Gargano"),"sample"] <- "Monte_Gargano"
  
  #create lgical vector matching sample names to species from Capsella list
  species <- Capsella_WGS_Sample_List$sample_name %in% win_pca$sample
  
  #create map for sampple name to species
  map <- unique(Capsella_WGS_Sample_List[species, c("sample_name","species")])
  
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, map, by = c("sample" = "sample_name"))
  #return the whole df
  return(df)
}
```


```{r directory variables}
post_dir = "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)
```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = post_dir, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(post_dir, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

Data cleaning and preparation.
```{r}
#remove the suffix from the list element names
names(dat) <- str_remove(names(dat), ".posterior")

# change the column names as well
```

To use lostruct, you need your data in a format with rows for each variant, and columns for each sample.

You can do this within the package if oyu have bcftools installed but I do not. :)

,The function eigen_windows() basically wants your data in a numeric matrix, with one row per variant and one column per sample (so that x[i,j] is the number of alleles that sample j has at site i). If your data are already in this form, then you can use it directly.

# Load VCF data
```{r load with VCFR, eval=FALSE}
# Get VCF file path
vcf_path <- "~/Documents/PhD/Research/CbpCr_Cbp_new_filtered.vcf.gz"
cbpcr <- read.vcfR(vcf_path, verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

```{r load with SNPRelate}
#open the GDS formatted file
(pruned_cbpcr.gsd <- snpgdsOpen("~/Documents/PhD/Research/old_local_ancestry_inference/ancestry_informative_sites/pruned_cbpcr.gds"))

#get SNP information
snplist <- snpgdsSNPList(pruned_cbpcr.gsd)

# extract numeric genotypes
snpr_genos <- snpgdsGetGeno(pruned_cbpcr.gsd, snpfirstdim = T)

# select sample IDs
meta <- snpgdsSummary(pruned_cbpcr.gsd)

#name the matrix columns with sample names
colnames(snpr_genos) <- meta[[1]]
```

```{r}
#compute local PCA coordinates
eigenstuff <- eigen_windows(snpr_genos, win=100, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca <- apply(eigenstuff, 1, reform_map)
```

### Assign windows to snpids
```{r}
wind <- rep(1:900, each = 100, length.out= nrow(snplist))

tail(wind)

snplist_wind <- cbind(wind, snplist)
``` 

```{r}
#compute local PCA coordinates; k is the number of PCs to return, win is number of windows to chop the genome into
eigenstuff <- eigen_windows(data=gt, win = 20, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

