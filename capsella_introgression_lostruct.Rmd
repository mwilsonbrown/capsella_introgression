---
title: "validation of Ancestry HMM using Lostruct"
author: "Maya Wilson Brown"
date: "2024-03-14"
output: html_document
---

Here, I will document a way that we validated that Ancestry HMM was pocking up on the kind of ancestry signals we expected.

We decided to use LOSTRUCT to look at a PCA at the locus level in our introgressed and non-introgressed loci of *Capsella bursa-pasoris*.

# Update: July 8, 2024
Updating Lostruct analysis with slightly different methods. 

```{r}
# load lostruct
library(lostruct)
library(vcfR)
```

Loading sample data

```{r capsella sequenced information}
# load capsella whole genome sequencing information
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

```{r defined populations}
#load C. bursa-pastoris population information
k3pops <- read.csv("~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", header = T, sep = "\t")

# ATM I do not have nyc samples in here so I will temporarily add them
nyc_pops <- wgs[which(wgs$citation == "R.Panko"), c("vcf_sample_name", "sample_name", "state", "latitude", "longitude", "latlong_approx")]

# change state column name to match pops df
colnames(nyc_pops)[3] <- "k3population"

# join data frames
pops <- rbind(k3pops, nyc_pops)
```

Join and keep only necessary information
```{r}
# join vcf data and population output from capsella_population_def
sample_info <- left_join(wgs, pops)
```

```{r}
# load matrix format of VCF
# geno <- read.csv("~/Documents/PhD/Research/capsella_introgression/test_ahmm_vcf.output", sep = "\t", header = F, na.strings = ".") #recode dots as NA

cbpcr <- read.vcfR("~/Desktop/ahmm_pruned_all.vcf.gz", verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
#gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

First, calculate the SNP density along each chromosome to determine good window sizes.

I know from the viterbi introgression results that the minimum tract length of any ancestry is 1000 basepairs with a median of about 12k and mean of about 80k.

Given the length of each chromosome, windowing by minimum base pairs will give me about 18-48K windows per chromosome.
```{r}
# Chromosome lengths from VCF header
# bcftools view -h ahmm_pruned_all.vcf.gz | grep '##contig'

# chromosome lengths
chrom.lens <- c(jlSCF_10=18059344,
                jlSCF_11=18860713,
                jlSCF_12=16958022,
                jlSCF_13=14108429,
                jlSCF_14=27977798,
                jlSCF_15=22212120,
                jlSCF_16=17841782,
                jlSCF_9=43809629)
# select sites
chroms <- cbpcr[,1]

# sum sites on each chromosome
sum(chroms@fix[,"CHROM"]=="jlSCF_9")

# posit
snps <- data.frame(chroms@fix[,c("CHROM","POS")])

# turn to list
snp_ls <- split(snps, snps[1])

test<- snp_ls[[1]]
test$POS <- as.numeric(test$POS)

test2 <- test %>% mutate(dist_n = lead(POS) - lag(POS))

summary(test2$dist_n)

# average SNPs per chromosome
snps_c <- unlist(lapply(snp_ls, nrow))
```
Base pairs between SNPs is pretty variable, but it seems like 
Compute the eigenstructure for windows along the genome.

I am going to split the gt matrix into chromosomes, so that I can apply a windowing function to each chromosome separately.
```{r}
# splitting the gt matrix by chromomosome
sc9 <- gt[1:max(which(str_detect(rownames(gt), "jlSCF_9"))),] #scaffold 9
sc10 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_9")))):max(which(str_detect(rownames(gt), "jlSCF_10"))),] #scaffold 10
sc11 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_10")))):max(which(str_detect(rownames(gt), "jlSCF_11"))),] #scaffold 11
sc12 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_11")))):max(which(str_detect(rownames(gt), "jlSCF_12"))),] #scaffold 12

sc13 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_12")))):max(which(str_detect(rownames(gt), "jlSCF_13"))),] #scaffold 13
sc14 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_13")))):max(which(str_detect(rownames(gt), "jlSCF_14"))),] #scaffold 14
sc15 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_14")))):max(which(str_detect(rownames(gt), "jlSCF_15"))),] #scaffold 15
sc16 <- gt[(1+max(which(str_detect(rownames(gt), "jlSCF_15")))):max(which(str_detect(rownames(gt), "jlSCF_16"))),] #scaffold 16
```

Fold all these into a list to make applying eigenwindows easier?
```{r}
scf_ls <- list(sc9,sc10,sc11,sc12,sc13,sc14,sc15,sc16)
```


```{r}
# calculate eigenvals and vecs for windows of size 3000 bp on scaffold 9
eigen9 <- lostruct::eigen_windows(data = sc9,
              win = 3000,
              k=2)
eigen10 <- lostruct::eigen_windows(data = sc10,
              win = 1000,
              k=2)

eigen11 <- lostruct::eigen_windows(data = sc11,
              win = 1000,
              k=2)
```

Testing with apply
```{r}
eigen_list <- lapply(scf_ls, lostruct::eigen_windows, win=3000, k=2)
```
I think the SNP calls on the other chromosomes have too many zeros, so I will ignore them for now.

# Plots??
The first window of scaffold 9 should be C. rubella for all of the NYC individuals. I think?

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
  # x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x, dat){
  #for each row, select all columns with PC1 in their name and store
  #pc1_val <- x[which(grepl("PC_1_", names(x[1:length(x)]), fixed = T))]
  pc1_val <- x[which(str_detect(colnames(dat), "PC_1_"))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_remove(names(pc1_val), "PC_1_")
  #and for PC2
  #pc2_val <- x[which(grepl("PC_2_", names(x[1:length(x)]), fixed = T))]
  pc2_val <- x[which(str_detect(colnames(dat), "PC_2_"))]
  #sample name
  sample_id2 <- str_remove(names(pc2_val), "PC_2_")

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, vcf_sample_name = sample_id)
  #create lgical vector matching sample names to species from Capsella list
  #species <- Capsella_WGS_Sample_List$sample_name %in% win_pca$sample
  
  #create map for sampple name to species
  #map <- unique(Capsella_WGS_Sample_List[species, c("sample_name","species")])
  
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, sample_info)
  #return the whole df
  df2 <- df[,c("vcf_sample_name","PC1", "PC2", "species", "k3population")]
  #return(df)
  return(df2)
}
```


Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca9 <- apply(eigen9, 1, reform_map, dat = eigen9)
```

Pivot longer to plot them all at once
```{r}
lpca9_long <- bind_rows(lpca9, .id = "window")
```

fill in NA for population
```{r}
lpca9_long$k3population <- tidyr::replace_na(lpca9_long$k3population, "Other Sp.")

lpca9_long$window <- factor(lpca9_long$window, levels = 1:20)

```

Plot please
```{r}
pc_plot1 <- ggplot() +
  geom_point(data=lpca9_long, aes(x=PC1, y=PC2, color = species, shape= k3population), size = 3) +
  theme_bw() + facet_wrap(~window)

pc_plot1

ggsave("lostruct_pca_scf9.png", pc_plot1, width = 10, height = 6, units = "in")
```


```{r}
pc_plot2 <- ggplot() +
  geom_point(data=lpca9[[2]], aes(x=PC1, y=PC2, color = species), size = 3) +
  theme_bw()

pc_plot2
```

#-----------------OLD CODE-----------------


```{r load libraries}
# necessary libraries
library(SNPRelate)
#library(vcfR)
library(lostruct)
library(tidyverse)
```
Lostruct functions

```{r lostruct functions}
# Function for reformatting lostruct output for easy plotting
  # x input is a data.frame from lostruct where each row is a window and the columns are eigenvals for each sample

reform_map <- function(x){
  #for each row, select all columns with PC1 in their name and store
  pc1_val <- x[which(grepl("PC_1", names(x[1:length(x)]), fixed = T))]
  #get sample name from named vector of PC1 values
  sample_id1 <- str_split_i(names(pc1_val), "_", -1)
  #and for PC2
  pc2_val <- x[which(grepl("PC_2", names(x[1:length(x)]), fixed = T))]
  #sample name
  sample_id2 <- str_split_i(names(pc2_val), "_", -1)

  #double check the sample names match
  ifelse(identical(sample_id1, sample_id2) == T, 
        sample_id <- sample_id2,
        print("Sample ID numbers do not match. Check vector indices."))
  # put PC1 values and PC2 values together in a data fram with sample names 
  win_pca <- data.frame(PC1 = pc1_val, PC2 = pc2_val, sample = sample_id)
  
  #change Monte Gargano sample name to be the full string
  win_pca[which(win_pca$sample == "Gargano"),"sample"] <- "Monte_Gargano"
  
  #create lgical vector matching sample names to species from Capsella list
  species <- Capsella_WGS_Sample_List$sample_name %in% win_pca$sample
  
  #create map for sampple name to species
  map <- unique(Capsella_WGS_Sample_List[species, c("sample_name","species")])
  
  # join the map key; it should not matter if it is left, right, or both join here since both should only have the number of samples
  df <- left_join(win_pca, map, by = c("sample" = "sample_name"))
  #return the whole df
  return(df)
}
```


```{r directory variables}
post_dir = "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)
```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = post_dir, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(post_dir, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

Data cleaning and preparation.
```{r}
#remove the suffix from the list element names
names(dat) <- str_remove(names(dat), ".posterior")

# change the column names as well
```

To use lostruct, you need your data in a format with rows for each variant, and columns for each sample.

You can do this within the package if oyu have bcftools installed but I do not. :)

,The function eigen_windows() basically wants your data in a numeric matrix, with one row per variant and one column per sample (so that x[i,j] is the number of alleles that sample j has at site i). If your data are already in this form, then you can use it directly.

# Load VCF data
```{r load with VCFR, eval=FALSE}
# Get VCF file path
vcf_path <- "~/Documents/PhD/Research/CbpCr_Cbp_new_filtered.vcf.gz"
cbpcr <- read.vcfR(vcf_path, verbose = TRUE)
# extract genotype matrix from vcfR object; This takes a hot second
gt <- extract.gt(cbpcr, element = 'GT', as.numeric = TRUE)
gt2 <- extract.gt(cbpcr, element = 'GT', as.numeric = FALSE)
```

```{r load with SNPRelate}
#open the GDS formatted file
(pruned_cbpcr.gsd <- snpgdsOpen("~/Documents/PhD/Research/old_local_ancestry_inference/ancestry_informative_sites/pruned_cbpcr.gds"))

#get SNP information
snplist <- snpgdsSNPList(pruned_cbpcr.gsd)

# extract numeric genotypes
snpr_genos <- snpgdsGetGeno(pruned_cbpcr.gsd, snpfirstdim = T)

# select sample IDs
meta <- snpgdsSummary(pruned_cbpcr.gsd)

#name the matrix columns with sample names
colnames(snpr_genos) <- meta[[1]]
```

```{r}
#compute local PCA coordinates
eigenstuff <- eigen_windows(snpr_genos, win=100, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

Now I apply the function to each row so each row (representing the results from a window) are each in a data frame stored in a list.
```{r}
# apply data reformatting function to output
lpca <- apply(eigenstuff, 1, reform_map)
```

### Assign windows to snpids
```{r}
wind <- rep(1:900, each = 100, length.out= nrow(snplist))

tail(wind)

snplist_wind <- cbind(wind, snplist)
``` 

```{r}
#compute local PCA coordinates; k is the number of PCs to return, win is number of windows to chop the genome into
eigenstuff <- eigen_windows(data=gt, win = 20, k=2)
#windows function outputs a matrix whose rows give the first two (k) eigenvalues and eigenvectors for each window
```

