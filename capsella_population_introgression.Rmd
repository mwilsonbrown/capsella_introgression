---
title: "Capsella rubella introgression to Capsella bursa-pastoris populations"
author: "Maya Wilson Brown"
date: "2024-02-20"
output: html_document
---
```{r}
library(ggplot2)
library(tidyr)
library(stringr)
library(dplyr)
#library(forcats) # do I actually use this package for anything?
```

# Capsella population admixture results and cluster assignment
Plotting and recording the admixture analysis in *Capsella bursa-pastoris* for analyzing group differences in introgressed regions

```{r directory variables}
admix_dir = "~/Documents/PhD/Research/admixture/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)

# join capsella information with VCF sample info
# change RP sample names to match database
#sample_name <- str_replace_all(a3$sample_name, "_S[0-9]+", "") #removes trailing _Snumber from rebecca's samples
```

Load in the ADMIXTURE output data

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
fam <- read.delim(paste0(admix_dir, "plink2_pruned_cbp.fam"), header=FALSE)

# read in Cross Validation (cv) error log
cv <- read.delim(paste0(admix_dir, "cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = admix_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```


Cross validation of lowest error K groups
```{r CV validation}
# crude plot of cross validation error rates; indices correspond to K
plot(cv$V2)

# get slopes of change between CV error rates; there is definitely a better way to think about this
# get index of shallowest negative slope
slopes <- (lead(cv$V2)-cv$V2)/(lead(1:6)-c(1:6)) # slopes
n.slopes <- slopes[slopes < 0] #only negative slopes
K = which.max(n.slopes) # shallowest negative slope is biggest number
#K = 3
print(K)
```

```{r combine k runs data}
# bind sample information to lowest CV error data frame
ancestry_dat <- cbind(fam[,2], ancestry_propsK[[K]])

# change column names to vector of sample name and various K populations
colnames(ancestry_dat) <- c("vcf_sample_name", paste0("pop", c(1:K)))
```

I want to order the bars by proportion of ancestry.
```{r}
ad_long <- pivot_longer(ancestry_dat, cols = colnames(ancestry_dat)[-1], names_to = "ancestry", values_to = "proportion")

# order rows by ancestry, then proportion
anc <- ad_long %>% arrange(desc(ancestry), proportion)

# order sample names to be in ancestry proportion order
lvl.order <- c(anc[1:nrow(fam), "vcf_sample_name"])$vcf_sample_name
#anc$sample_name <- factor(anc$sample_name, levels = unique(anc$sample_name))
anc$vcf_sample_name <- factor(anc$vcf_sample_name, levels = lvl.order)

ggplot(anc, aes(fill=ancestry, y=proportion, x=vcf_sample_name)) + 
  geom_bar(position="fill", stat="identity") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 7),legend.position="none",panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "#E64B35FF", "pop3" = "orchid1")) + xlab("sample name")

#ggsave("cbp_k3_ordered.png", width = 13, height = 7, units = "in")
```


```{r}
dplus_pop3 <- dplus3[,c("pop1","pop2","pop3")]

K3_clusters <- colnames(dplus_pop3)[apply(dplus_pop3,1, which.max)]

#dplus_pop2 <- dplus2[,c("pop1","pop2")]
#K2_clusters <- colnames(dplus_pop2)[apply(dplus_pop2,1, which.max)]


#cluster assignments for samples

#### REMEBER THE POPULATIONS DO NOT MATCH BETWEEN K2 AND K3!!!!! IT'S AN ARBITRARY NAME FOR A CLUSTER
#admix_cluster_assignment <- data.frame(sample_name = dplus2$sample_name, k2_pop = K2_clusters, k3_pop = K3_clusters)
```

```{r}
#object admix_cluster_assignment generated in cbp_admixture
#admix_cluster_assignment <- read.delim("~/Documents/PhD/Research/admixture/admix_cluster_assignment.txt")
```

Figuring out exactly who is in each group and where they are from.
```{r eval=FALSE}
# When K=3
k3_1 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop1"),]
# Taiwan, South East and North East China

k3_2 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop2"),]
# germany, poland, netherlands, iceland, sweden russia, NW China, NE France near Germany, near Scotland, SW France

k3_3 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop3"),] #Italy Spain, Greece, Jordan, Algeria, Turkey
```

# Introgression in Capsella bursa-pastoris

```{r ancestry colors}
anc.cols <- c(bursa_pastoris = "#a9ba9d", rubella = "pink", heterozygous = "grey")
```

Load Ancestry HMM output
```{r ancestry_hmm output paths}
#paths to data output by Ancestry HMM
## posterior probabilities
ahmm_post_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"

## viterbi decoding
ahmm_vit_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_viterbi/"

```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = ahmm_post_path, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_post_path, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

I got ride of the posterior probability decoding, so no plots are here and at this time, I do nothing with the posterior data.
# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name
#names(vit) <- str_replace_all(names(vit), "_S[0-9]+", "") #remove S number from NYC samples
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit_out <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit_out, idcol = "vcf_sample_name")

# explicitly make 'vcf_sample_name' a factor and order by ancestry proportion
vit_all$vcf_sample_name <- factor(vit_all$vcf_sample_name, levels = lvl.order)
```


```{r landscape plot, eval=FALSE, echo=FALSE}
ggplot() + geom_segment(data = subset(vit_all, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

#ggsave("nyc_viterbi_SCF9_landscape.png", units = "in", height = 7, width = 12)
```

NA named individual in this sample set is 774. Sample is in ancestry HMM analysis but missing from ADMIXTURE analysis, so level ordering of samples sets 774 to NA.

###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

I will start by combinging the viterbi decoding with the whole genome sequencing data
```{r}
# make new column with the trailing S[number] removed from Panko samples
vit_all$sample_name <- str_remove_all(vit_all$vcf_sample_name, "_S[0-9]+")

# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, wgs)

```

Starting with the NYC samples

```{r}
# select rubella tracts
ny_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & (vit_all$state == "NY" | vit_all$state == "NJ"),]
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- ny_rubella_tracts[,c("vcf_sample_name","chrom","start","end")]

# break up data frame by sample
ny_rub_by_sample <- split(temp, temp$vcf_sample_name)

# drop the sample id column from all
ny_rub_by_sample <- lapply(ny_rub_by_sample, function(x){
  x[,-"vcf_sample_name"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(ny_rub_by_sample)){
#   write.table(ny_rub_by_sample[[i]], paste0(names(ny_rub_by_sample)[i], "ny_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```

Now do the same for Mediterranean samples.

```{r}
# select rubella tracts
med_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & (vit_all$state == "NY" | vit_all$state == "NJ"),] #should be some other identifier
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- med_rubella_tracts[,c("vcf_sample_name","chrom","start","end")]

# break up data frame by sample
med_rub_by_sample <- split(temp, temp$vcf_sample_name)

# drop the sample id column from all
med_rub_by_sample <- lapply(med_rub_by_sample, function(x){
  x[,-"vcf_sample_name"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(med_rub_by_sample)){
#   write.table(med_rub_by_sample[[i]], paste0(names(med_rub_by_sample)[i], "med_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```
#### Genic Content
