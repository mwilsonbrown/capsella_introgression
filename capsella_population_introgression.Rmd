---
title: "Capsella rubella introgression to Capsella bursa-pastoris populations"
author: "Maya Wilson Brown"
date: "2024-02-20"
output: html_document
---
```{r}
library(ggplot2)
library(tidyr)
library(stringr)
library(dplyr)
library(tidygeocoder) # for grabbing lat and long from city names
library(rnaturalearth) # for maps
#library(forcats) # do I actually use this package for anything?
```

I have written functions for the plots I want and selecting K.
We can source the functions from capsella_pop_introgression_functions.R
```{r}
source("~/Documents/PhD/Research/capsella_introgression/capsella_pop_introgressin_functions.R")
```

```{r directory variables}
# all Capsella bursa-pastoris in vcf file
admix_dir = "~/Documents/PhD/Research/admixture/all_cbp"
# only Cbp in Pop3 when k=3 in all CBP admixture result (generally northern europe and NYC)
eu_admix_dir = "~/Documents/PhD/Research/admixture/european/"
# only ancestral range of CBP in Eurasia
eurasian_dir = "~/Documents/PhD/Research/admixture/eurasian/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)
```

# Capsella population admixture results and cluster assignment
Plotting and recording the admixture analysis in *Capsella bursa-pastoris* for analyzing group differences in introgressed regions

Load in the ADMIXTURE output data

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
cap_fam <- read.delim(paste0(admix_dir, "plink2_pruned_cbp.fam"), header=FALSE)

# read in Cross Validation (cv) error log
cap_cv <- read.delim(paste0(admix_dir, "cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = admix_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

cap_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  cap_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```


Cross validation of lowest error K groups
```{r CV validation of all Capsella bursa-pastoris}
K = selectK(cap_cv)
print(K)
```


```{r}
# make ancestry bars plot
cap_k3 <- ancestry_bars(cap_ancestry_propsK, K = K, cap_fam, scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "#E64B35FF", "pop3" = "orchid1")))

# plot
cap_k3
# save image
ggsave("./plots_temp/cbp_k3.png", width = 13, height = 7, units = "in")
```


Figuring out exactly who is in each group and where they are from.
```{r eval=FALSE}
# just left in for quick referencing
# When K=3
k3_1 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop1"),]
# Taiwan, South East and North East China

k3_2 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop2"),]
# germany, poland, netherlands, iceland, sweden russia, NW China, NE France near Germany, near Scotland, SW France

k3_3 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop3"),] #Italy Spain, Greece, Jordan, Algeria, Turkey
```

```{r location data for Capsella clusters}
# combine with location information
cap_k3_anc_info <- ancestry_location(cap_k3$data, wgs)

# get sample name to k group key
cap_k3_key <- assign_ancestry(cap_ancestry_propsK, 3, cap_fam)

# combine key with location data
cap_k3 <- left_join(cap_k3_anc_info, cap_k3_key)
```

Clusters on a map
```{r all Capsella maps}
world + geom_point(data=cap_k3, aes(x=longitude, y=latitude, fill = anc_group, color = NULL), shape=21) +
  scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "#E64B35FF", "pop3" = "orchid1"))

ggsave("./plots_temp/cbp_k3_map.png", width = 13, height = 7, units = "in")
```

# European Only admixture
We are interested in how the Admixture group containing genotypes from northern Europe compare to NYC. I ran another admixture analysis only including individuals that have 60% or more ancestry proportion belonging to Population 3 when K=3 (Red individuals above).

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
eu_fam <- read.delim(paste0(eu_admix_dir, "plink2_pruned_cbp.fam"), header=FALSE)

# read in Cross Validation (cv) error log
eu_cv <- read.delim(paste0(eu_admix_dir, "cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = eu_admix_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

eu_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(eu_admix_dir, file)  # Get the full file path
  eu_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```

```{r}
# plot cv error rate scatter and save selected K to K
K = selectK(eu_cv)
```

Variation between the CV error rates in incredibly small here, so there may be some merit to any of the K values above 2. However, K here is selected.

I will look at a ploot of all the K groupings together.
```{r}
# ancestry bars for only those in European (red) group above
eu_k2 <- ancestry_bars(eu_ancestry_propsK, K = K, sample_names_fam = eu_fam)

# make just the plot show up
plot(eu_k2)

# save plot
ggsave("./plots_temp/eu_cbp_k2.png", width = 13, height = 7, units = "in")
```


A majority of the NYC samples are groups together within the same population.
```{r, eval=FALSE}
# print locations for "non-admixed" samples of each population

#Eurasia
eu_k2_anc[eu_k2_anc$ancestry == "pop2" & eu_k2_anc$proportion > 0.8,]

# NYC
eu_k2_anc[eu_k2_anc$ancestry == "pop1" & eu_k2_anc$proportion > 0.8,]
```

###### Ancestry maps

```{r}
# save the ancestry data
eu_k2_anc_info <- ancestry_location(eu_k2$data, wgs)
```

### Map Time!

Color by ancestry proportion

Assigning ancestry by k groups

```{r}
# get sample to majority ancestry population key
k2_key <- assign_ancestry(eu_ancestry_propsK, K=2, eu_fam)

# join key to location information
eu_k2 <- left_join(eu_k2_anc_info, k2_key)
```

Color by ancestry group.

REMEBER WHEN PLOTTING, THE POPULATIONS DO NOT MATCH BETWEEN Ks!!!!! IT'S AN ARBITRARY NAME FOR A CLUSTER. POP1 WHEN K=4 IS NOT THE SAME AS POP1 WHEN K=2.

```{r}
ny_map + geom_point(data=subset(eu_k2, state == c("NY", "NJ")), aes(x=longitude, y=latitude, fill = anc_group), shape = 21)

ggsave("./plots_temp/eu_cbp_k2_ny_map.png", width = 13, height = 7, units = "in")
```
```{r}
eurasia + geom_point(data=subset(eu_k2, citation != "R. Panko"), aes(x=longitude, y=latitude, fill = anc_group, color = NULL), shape=21)

ggsave("./plots_temp/eu_cbp_k2_eurasia_map.png", width = 13, height = 7, units = "in")
```

Get data for K=4 and plot on maps
```{r}
# data for k = 4 on European group data
eu_k4 <- ancestry_bars(eu_ancestry_propsK, K = 4, sample_names_fam = eu_fam, ggplot_opt = scale_fill_manual(values = c("pop1" = "#2B3A67", "pop2" = "#84A98C", "pop3" = "#DA2C38", "pop4" = "#FFC482")))

# make just the plot show up
plot(eu_k4)

ggsave("./plots_temp/eu_cbp_k4.png", width = 13, height = 7, units = "in")
```


```{r}
# k=4 data prep
eu_k4_anc_info <- ancestry_location(eu_k4$data, wgs)

# get sample to majority ancestry population key
k4_key <- assign_ancestry(eu_ancestry_propsK, K=4, eu_fam)

# join key to location information
eu_k4 <- left_join(eu_k4_anc_info, k4_key)
```

```{r}
# new york map
ny_map + geom_point(data=subset(eu_k4, state == c("NY", "NJ")), aes(x=longitude, y=latitude, fill = anc_group), shape=21, stroke = 2) +
  scale_fill_manual(values = c("pop1" = "#2B3A67", "pop2" = "#84A98C", "pop3" = "#DA2C38", "pop4" = "#FFC482"))

ggsave("./plots_temp/eu_cbp_k4_ny_map.png", width = 13, height = 7, units = "in")
```

```{r}
# world map
eurasia + geom_point(data=subset(eu_k4, citation != "R. Panko"), aes(x=longitude, y=latitude, fill = anc_group, color = NULL), shape=21) +
  scale_fill_manual(values = c("pop1" = "#2B3A67", "pop2" = "#84A98C", "pop3" = "#DA2C38", "pop4" = "#FFC482"))

ggsave("./plots_temp/eu_cbp_k4_eurasia_map.png", width = 13, height = 7, units = "in")
```
From the above plots, we can see that population 4 when k=4 is a population "unique" to New York.

```{r pop4 when k is 4 in the European Group}
# confirming all population 4 individuals come from NYC
unique(eu_k4[eu_k4$anc_group == "pop4", "citation"])
```
#### ADMIXTURE conditioned on K

If we just think about ADMIXTURE and STRUCTURE as ways to select a valuable K number of ancestral groups, it makes sense to run admixture on the Eurasian C. bursa-pastoris samples on their own, and select the best K groups from the ancestral population. Then, using that K, I would run ADMIXTURE on only the NYC populations and assign the NYC population to those K ancestral groups. I am not sure of the best way to match between the populations, but I may just have to look at the allele frequencies in the inferred ancestral populations and match them that way.

I do feel that is analysis has already been done by Kryvohkhyzha and colleagues to some capacity.

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
ea_fam <- read.delim(paste0(eurasian_dir, "eurasian_cbp.fam"), header=FALSE)

# read in Cross Validation (cv) error log
ea_cv <- read.delim(paste0(eurasian_dir, "eurasian_cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = eurasian_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

ea_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(eurasian_dir, file)  # Get the full file path
  ea_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```

```{r}
# plot cv error rate scatter and save selected K to K
K = selectK(ea_cv)
```
K = four would also be valid to look at.

```{r}
# data for k = 4 on European group data
ea_k2 <- ancestry_bars(ea_ancestry_propsK, K = K, sample_names_fam = ea_fam)

# make just the plot show up
plot(ea_k2)

ggsave("~/Documents/PhD/Research/admixture/plots_temp/eurasian_cbp_k2.png", width = 13, height = 7, units = "in")
```
Same information largely, but on a map (just to confirm my suspicions).
```{r}
# k=4 data prep
ea_k2_anc_info <- ancestry_location(ea_k2$data, wgs)

# get sample to majority ancestry population key
k2_key <- assign_ancestry(ea_ancestry_propsK, K=2, ea_fam)

# join key to location information
ea_k2 <- left_join(ea_k2_anc_info, k2_key)
```

```{r}
# world map
world + geom_point(data=ea_k2, aes(x=longitude, y=latitude, fill = anc_group, color = NULL), shape=21)

#ggsave("~/Documents/PhD/Research/admixture/plots_temp/eurasian_cbp_k2_eurasia_map.png", width = 13, height = 7, units = "in")
```

# Introgression in Capsella bursa-pastoris

```{r ancestry colors}
# another option for pink color is #C5839A; I was using "pink" before (FFC0CB), #E2A2B3, or just 'mistyrose'
anc.cols <- c(bursa_pastoris = "#a9ba9d", rubella = "#F1D1D9", heterozygous = "#96938E")

# a warm gray or green grey need to be quite dark for it to be appropriate for all forms of colorblindness
```

Load Ancestry HMM output
```{r ancestry_hmm output paths}
#paths to data output by Ancestry HMM
## viterbi decoding
ahmm_vit_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_viterbi/"

```


# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name
#names(vit) <- str_replace_all(names(vit), "_S[0-9]+", "") #remove S number from NYC samples
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit_out <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit_out, idcol = "vcf_sample_name")

# explicitly make 'vcf_sample_name' a factor and order by ancestry proportion
vit_all$vcf_sample_name <- factor(vit_all$vcf_sample_name, levels = lvl.order)
```


```{r landscape plot, eval=FALSE, echo=FALSE}
ggplot() + geom_segment(data = subset(vit_all, chrom == "SCF_9" & ), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

#ggsave("cbp_viterbi_SCF9_landscape.png", units = "in", height = 7, width = 12)
```

NA named individual in this sample set is 774. Sample is in ancestry HMM analysis but missing from ADMIXTURE analysis, so level ordering of samples sets 774 to NA.

###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

I will start by combinging the viterbi decoding with the whole genome sequencing data
```{r}
# make new column with the trailing S[number] removed from Panko samples
vit_all$sample_name <- str_remove_all(vit_all$vcf_sample_name, "_S[0-9]+")

# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, wgs)

```
NYC only introgression plot
```{r nyc_introgression_plot}
ggplot() + geom_segment(data = subset(vit_all, (chrom == "SCF_16" & (state == "NY" | state == "NJ"))), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 16") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_viterbi_SCF16.png", units = "in", height = 7, width = 12)
```
```{r nyc_introgression_plot_allScaffolds}
ggplot() + geom_segment(data = subset(vit_all, (state == "NY" | state == "NJ")), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) +
  scale_color_manual(values=anc.cols) + 
  ggtitle("New York introgression patterns") + 
  ylab("position") + xlab("Sample Name") + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8)) +
   facet_wrap(~chrom, scales = "free_y")

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_viterbi_all.png", units = "in", height = 12, width = 19)
```
Starting with the NYC samples

```{r}
# select rubella tracts
ny_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & (vit_all$state == "NY" | vit_all$state == "NJ"),]
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- ny_rubella_tracts[,c("vcf_sample_name","chrom","start","end")]

# break up data frame by sample
ny_rub_by_sample <- split(temp, temp$vcf_sample_name)

# drop the sample id column from all
ny_rub_by_sample <- lapply(ny_rub_by_sample, function(x){
  x[,-"vcf_sample_name"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(ny_rub_by_sample)){
#   write.table(ny_rub_by_sample[[i]], paste0(names(ny_rub_by_sample)[i], "ny_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```

Now do the same for Mediterranean samples.

```{r}
# select rubella tracts
med_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & vit_all$vcf_sample_name %in% c("39-12-28","70.5","AL87","JO56","JO59","TR73","WAC5"),] #should be some other identifier
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- med_rubella_tracts[,c("vcf_sample_name","chrom","start","end")]

# break up data frame by sample
med_rub_by_sample <- split(temp, temp$vcf_sample_name)

# drop the sample id column from all
med_rub_by_sample <- lapply(med_rub_by_sample, function(x){
  x[,-"vcf_sample_name"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(med_rub_by_sample)){
#   write.table(med_rub_by_sample[[i]], paste0(names(med_rub_by_sample)[i], "med_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```

### Commonly introgressed regions

This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and *multi-inter* from BEDTools
```{r}
# load file
nyc_inter <- read.delim("~/Documents/PhD/Research/admixture/old/nyc_multiinter_rubella.txt")

# smaller working file since BEDTools outputs more information than I need
nyc_inter <- nyc_inter[,1:4]
```

```{r NY Crubella chunks gradient}
# mistyrose = #FFE4E1, violetred4 = #8B2252
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = nyc_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("New York introgressed region frequency") + theme_classic()

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_freq.png", units = "in", height = 12, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = nyc_inter, binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
 
I will define an introgressed segment as common if it is present in at least 33 individuals (a little over 50% of our NYC samples)

```{r}
# get the common chunks
nyc_common_chunks <- nyc_inter[nyc_inter$num >= 33,]
```


```{r join common with nyc data}
#prepping to join with larger dataset
nyc_common_chunks$vcf_sample_name <- "common"
nyc_common_chunks$ancestry <- "rubella"

ny_rubella_common <- rbind(ny_rubella_tracts, nyc_common_chunks, fill=T)
```

```{r nyc and common rubella chunks}
ggplot() + geom_segment(data = subset(ny_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: New York") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

# Looks quite good actually!
```


```{r nyc and common rubella chunks all}
ggplot() + geom_segment(data = ny_rubella_common, aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("New York introgrressed regions shared by 33 or more individuals") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10)) +
  facet_wrap(~chrom, scales = "free_y")

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_common.png", units = "in", height = 12, width = 19)
```


Now again with the Mediterranean samples
```{r}
# load file
med_inter <- read.delim("~/Documents/PhD/Research/admixture/old/med_rubella_chunks/med_multiinter_rubella.txt")

# smaller working file since BEDTools outputs more information than I need
med_inter <- med_inter[,1:4]
```

```{r NY Crubella chunks gradient}
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = med_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("Mediterranean introgressed regions") + theme_classic()
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = med_inter, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
 
I will define an introgressed segment as common here if it is present in at least 4 individuals from our Mediterranean group

```{r}
# get the common chunks
med_common_chunks <- med_inter[med_inter$num >= 4,]
```

### Med rubella tracts does not exist yet because I do not have a way to select
```{r join common with med data}
#prepping to join with larger dataset
med_common_chunks$vcf_sample_name <- "common"
med_common_chunks$ancestry <- "rubella"

med_rubella_common <- rbind(med_rubella_tracts, med_common_chunks, fill=T)
```

```{r nyc and common rubella chunks}
ggplot() + geom_segment(data = subset(med_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: Mediterranean") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))
```


#### Genic Content
We may be interested in comparing the number of genes in introgressed regions vs non-introgressed regions. To do this, we can use BEDTools intersect to see how many basepairs of genes from a Genome Feature File (GFF) intersect with basepairs from introgressed or non-introgressed regions.

I will create BEDfiles of non-intorgressed regions as before.

#### PI in introgressed regions
To look at pairwise diversity in introgressed regions, first, I assigned individual Capsella bursa-pastoris to different populations where individuals are a part of 3 main lineages: Asian, with no introgression; Mediterranean, with introgression; and European/NewYorker, with introgression.

First, I looked at pairwise diversity in each population using sliding windows of 10,000 base pairs across the whole genome.

```{r whole genome pi, eval = FALSE}
### With the newly generated VCF
pi_v1 <- read.delim("~/Documents/PhD/Research/capsella_introgression_git_temp/windows_v1_pi.txt")

#plot
pi_v1 %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi across whole genome") +
  theme_bw()
```

Now for the nyc and mediterranean introgressed regions on their own.
```{r}
### With the newly generated VCF
pi_nyc <- read.delim("~/Documents/PhD/Research/capsella_introgression_git_temp/nyc_int_v1_pi.txt")

#plot
pi_nyc %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi in NYC introgressed regions only")
  
```
An interesting comparison here might be between NYC samples and other (northern) European cluster samples.

```{r}
### With the newly generated VCF
pi_med <- read.delim("~/Documents/PhD/Research/capsella_introgression_git_temp/med_int_v1_pi.txt")

#plot
pi_med %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi in Mediterranean introgressed regions only")
```
Not sure that this means yet, but my first thoughts are that for commonly introgressed regions in the mediterranean

#### SIDEBAR
I wonder if we zoom in on Pi in NYC for introgressed regions that are present in all 65 individuals.
```{r eval=FALSE}
# select regions present in all individiuals
nyc_retained_chunks <- nyc_inter[nyc_inter$num == 65,]

# save whole genome data as ggplot
wg_nyc_pi <- pi_v1[pi_v1$pop == "p2_nyc",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi))+
  geom_line()

# plot only those regions?
pi_nyc[pi_nyc$pop == "p2_nyc",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  ggtitle("Pi in NYC introgressed regions only")

# plot only those regions?
int_r_nyc_pi <- pi_nyc[pi_nyc$pop == "p2_nyc",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~chromosome)
  ggtitle("Pi in NYC introgressed regions shared by >=33 genotypes")
```

