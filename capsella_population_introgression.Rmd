---
title: "Capsella rubella introgression to Capsella bursa-pastoris populations"
author: "Maya Wilson Brown"
date: "2024-02-20"
output: html_document
---
```{r}
library(ggplot2)
library(tidyr)
library(stringr)
library(dplyr)
#library(forcats) # do I actually use this package for anything?
```

# Capsella population admixture results and cluster assignment
Plotting and recording the admixture analysis in *Capsella bursa-pastoris* for analyzing group differences in introgressed regions

```{r directory variables}
admix_dir = "~/Documents/PhD/Research/admixture/"
```

####### Needs Updating
First, I need to get a list of only the Cbp samples in the VCF I have created
```{r}
## To Do: Clean up and update loading sample information

# load metadata
wgs <- read.delim("~/Documents/PhD/Research/old_local_ancestry_inference/ancestry_informative_sites/Capsella_WGS_Sample_List.txt", header=T)

# load rebecca meta
panko <- read.csv("~/Documents/PhD/Research/ahmm_local_inference/NYC Capsella bursa-pastoris bulking & tissue log_12.5.xlsb.xlsx - full population info.csv")

#clean panko dataset info
panko$sample_id <- paste(panko$Population.., panko$Plant.., sep = "_")

sm_panko <- panko[c("sample_id", "Latitude", "Longitude", "City", "State")]

# load list of sample names
vcf_samples <- read.delim("~/Desktop/vcf_samples.txt", header=F)
```

```{r}
# join information
joined <- left_join(vcf_samples, wgs, join_by("V1" == "sample_name"))

joined <- joined[ ,c("V1", "species", "latitude", "longitude", "note")]

joined$species <- joined$species %>% replace_na("Capsella bursa-pastoris")

cbp <- joined[joined$species == "Capsella bursa-pastoris",]

write.table(cbp, file="cbp_inVCF.txt", quote = F, sep = "\t", row.names = F, col.names = F)
```

Load in the ADMIXTURE output data

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
fam <- read.delim(paste0(admix_dir, "test.fam"), header=FALSE)

# read in Cross Validation (cv) error log
cv <- read.delim(paste0(admix_dir, "cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = admix_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```

Cross validation of lowest error K groups
```{r CV validation}
# crude plot of cross validation error rates; indices correspond to K
plot(cv$V2)

# get index of whichever K grouping has smallest CV error
#K = which.min(cv$V2)
K = 3
print(K)
```

```{r combine k runs data}
# bind sample information to lowest CV error data frame
ancestry_dat <- cbind(fam[,2], ancestry_propsK[[K]])

# change column names to vector of sample name and various K populations
colnames(ancestry_dat) <- c("sample_name", paste0("pop", c(1:K)))
```

```{r}
# outdated but leaving here for correction
temp3 <- cbind(fam, dat[[6]])

colnames(temp3) <- c("famID","sample_name","momID","dadID","sex","phenotype","pop1","pop2", "pop3")

temp3 <- temp3[,c("sample_name", "pop1", "pop2","pop3")]

#add location information?
# would want to use the coalesce function here 
a3 <- left_join(temp3, wgs)

a3 <- a3[ ,c("sample_name","pop1","pop2","pop3","latitude", "longitude", "citation", "note")]

# change RP sample names to match database
a3$sample_name <- str_replace_all(a3$sample_name, "_S[0-9]+", "") #removes trailing _Snumber from rebecca's samples

# add location information from RP
b3 <- left_join(a3, sm_panko, join_by("sample_name" == "sample_id"))

# coalesce the location information
c3 <- b3 %>% mutate(lat = coalesce(latitude, Latitude), long = coalesce(longitude, Longitude))

# then finally only keep columns wanted
d3 <- c3[, c("sample_name","pop1","pop2", "pop3", "lat", "long", "citation","note","State")]

# fill Panko citations
d3$citation <- as.character(d3$citation) %>% replace_na("R_Panko")
#reorder based on citation
dplus3 <- with(d3, d3[order(citation),])

dplus3$sample_name <- factor(dplus3$sample_name, levels = dplus3$sample_name)

k3plus <- pivot_longer(dplus3, cols = c("pop1", "pop2", "pop3"), names_to = "ancestry", values_to = "proportion")
#k3 <- pivot_longer(keep, cols = c("pop1", "pop2","pop3"), names_to = "ancestry", values_to = "proportion")
```


I want to order the bars by proportion of ancestry.
```{r}
k3 <- pivot_longer(ancestry_dat, cols = colnames(ancestry_dat)[-1], names_to = "ancestry", values_to = "proportion")

# order rows by ancestry, then proportion
anc <- k3 %>% arrange(desc(ancestry), proportion)


# order sample names to be in ancestry proportion order
lvl.order <- c(anc[1:nrow(fam), "sample_name"])$sample_name
#anc$sample_name <- factor(anc$sample_name, levels = unique(anc$sample_name))
anc$sample_name <- factor(anc$sample_name, levels = lvl.order)

ggplot(anc, aes(fill=ancestry, y=proportion, x=sample_name)) + 
  geom_bar(position="fill", stat="identity") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 7),legend.position="none",panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "#E64B35FF", "pop3" = "orchid1")) + xlab("sample name")

#ggsave("cbp_k3_ordered.png", width = 13, height = 7, units = "in")
```


```{r}
dplus_pop3 <- dplus3[,c("pop1","pop2","pop3")]

K3_clusters <- colnames(dplus_pop3)[apply(dplus_pop3,1, which.max)]

#dplus_pop2 <- dplus2[,c("pop1","pop2")]
#K2_clusters <- colnames(dplus_pop2)[apply(dplus_pop2,1, which.max)]


#cluster assignments for samples

#### REMEBER THE POPULATIONS DO NOT MATCH BETWEEN K2 AND K3!!!!! IT'S AN ARBITRARY NAME FOR A CLUSTER
#admix_cluster_assignment <- data.frame(sample_name = dplus2$sample_name, k2_pop = K2_clusters, k3_pop = K3_clusters)
```
```{r}
#object admix_cluster_assignment generated in cbp_admixture
#admix_cluster_assignment <- read.delim("~/Documents/PhD/Research/admixture/admix_cluster_assignment.txt")
```

Figuring out exactly who is in each group and where they are from.
```{r eval=FALSE}
# When K=3
k3_1 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop1"),]
# Taiwan, South East and North East China

k3_2 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop2"),]
# germany, poland, netherlands, iceland, sweden russia, NW China, NE France near Germany, near Scotland, SW France

k3_3 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop3"),] #Italy Spain, Greece, Jordan, Algeria, Turkey
```

# Introgression in Capsella bursa-pastoris

```{r ancestry colors}
anc.cols <- c(bursa_pastoris = "#a9ba9d", rubella = "pink", heterozygous = "grey")
```

Load Ancestry HMM output
```{r ancestry_hmm output paths}
#paths to data output by Ancestry HMM
## posterior probabilities
ahmm_post_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"

## viterbi decoding
ahmm_vit_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_viterbi/"

```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = ahmm_post_path, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_post_path, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

I got ride of the posterior probability decoding, so no plots are here and at this time, I do nothing with the posterior data.
# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name
#names(vit) <- str_replace_all(names(vit), "_S[0-9]+", "") #remove S number from NYC samples
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit_out <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit_out, idcol = "sample_name")

# explicitly make 'sample_name' a factor and order by ancestry proportion
vit_all$sample_name <- factor(vit_all$sample_name, levels = lvl.order)
```


```{r landscape plot, eval=FALSE, echo=FALSE}
ggplot() + geom_segment(data = subset(vit_all, chrom == "SCF_9"), aes(color= ancestry, x=sample_name, xend=sample_name, y=start, yend=end), size = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

#ggsave("nyc_viterbi_SCF9_landscape.png", units = "in", height = 7, width = 12)
```

NA named individual in this sample set is 774. Sample is in ancestry HMM analysis but missing from ADMIXTURE analysis, so level ordering of samples sets 774 to NA.

###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

Starting with the NYC samples

```{r}
# select rubella tracts
nyc_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & (vit_all$State == "NY" | vit_all$State == "NJ"),] #the state column does not exist yet but it can and will!

# first need to only do comparisons within scaffolds
nyc_rubella_scf_tracts <- split(nyc_rubella_tracts, nyc_rubella_tracts$chrom) # each list element is a scaffold, multiple rows for each sample

# separate the genes the same way
genes_scf_tracts <- split(genes_gff_gr, genes_gff_gr$chrom)
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- nyc_rubella_tracts[,c("sample_id","chrom","start","end")]

# break up data frame by sample
nyc_rub_by_sample <- split(temp, temp$sample_id)

# drop the sample id column from all
nyc_rub_by_sample <- lapply(nyc_rub_by_sample, function(x){
  x[,-"sample_id"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(nyc_rub_by_sample)){
#   write.table(nyc_rub_by_sample[[i]], paste0(names(nyc_rub_by_sample)[i], "_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```

#### Genic Content
