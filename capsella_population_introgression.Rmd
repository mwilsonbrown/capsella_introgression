---
title: "Capsella rubella introgression to Capsella bursa-pastoris populations"
author: "Maya Wilson Brown"
date: "2024-02-20"
output: html_document
---
```{r}
library(ggplot2)
library(tidyr)
library(stringr)
library(dplyr)
library(tidygeocoder) # for grabbing lat and long from city names
library(rnaturalearth) # for maps
#library(forcats) # do I actually use this package for anything?
```

# Capsella population admixture results and cluster assignment
Plotting and recording the admixture analysis in *Capsella bursa-pastoris* for analyzing group differences in introgressed regions

```{r directory variables}
admix_dir = "~/Documents/PhD/Research/admixture/"
eu_admix_dir = "~/Documents/PhD/Research/admixture/european/"
```

```{r capsella sequenced information}
wgs <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_combined_wgs.txt", sep = "\t", header = T)

# join capsella information with VCF sample info
# change RP sample names to match database
#sample_name <- str_replace_all(a3$sample_name, "_S[0-9]+", "") #removes trailing _Snumber from rebecca's samples
```

Load in the ADMIXTURE output data

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
fam <- read.delim(paste0(admix_dir, "plink2_pruned_cbp.fam"), header=FALSE)

# read in Cross Validation (cv) error log
cv <- read.delim(paste0(admix_dir, "cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = admix_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```


Cross validation of lowest error K groups
```{r CV validation}
# crude plot of cross validation error rates; indices correspond to K
plot(cv$V2)

# get slopes of change between CV error rates; there is definitely a better way to think about this
# get index of shallowest negative slope
slopes <- (lead(cv$V2)-cv$V2)/(lead(1:6)-c(1:6)) # slopes
n.slopes <- slopes[slopes < 0] #only negative slopes
K = which.max(n.slopes) # shallowest negative slope is biggest number
#K = 3
print(K)
```

```{r combine k runs data}
# bind sample information to lowest CV error data frame
ancestry_dat <- cbind(fam[,2], ancestry_propsK[[K]])

# change column names to vector of sample name and various K populations
colnames(ancestry_dat) <- c("vcf_sample_name", paste0("pop", c(1:K)))
```

I want to order the bars by proportion of ancestry.
```{r cbp_k3_admixture}
ad_long <- pivot_longer(ancestry_dat, cols = colnames(ancestry_dat)[-1], names_to = "ancestry", values_to = "proportion")

# order rows by ancestry, then proportion
anc <- ad_long %>% arrange(desc(ancestry), proportion)

# order sample names to be in ancestry proportion order
lvl.order <- c(anc[1:nrow(fam), "vcf_sample_name"])$vcf_sample_name
#anc$sample_name <- factor(anc$sample_name, levels = unique(anc$sample_name))
anc$vcf_sample_name <- factor(anc$vcf_sample_name, levels = lvl.order)

ggplot(anc, aes(fill=ancestry, y=proportion, x=vcf_sample_name)) + 
  geom_bar(position="fill", stat="identity") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 7),legend.position="none",panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "#E64B35FF", "pop3" = "orchid1")) + xlab("sample name")

#ggsave("./plots_temp/cbp_k3.png", width = 13, height = 7, units = "in")
```


```{r, eval=FALSE}
dplus_pop3 <- dplus3[,c("pop1","pop2","pop3")]

K3_clusters <- colnames(dplus_pop3)[apply(dplus_pop3,1, which.max)]

#dplus_pop2 <- dplus2[,c("pop1","pop2")]
#K2_clusters <- colnames(dplus_pop2)[apply(dplus_pop2,1, which.max)]


#cluster assignments for samples

#### REMEBER THE POPULATIONS DO NOT MATCH BETWEEN K2 AND K3!!!!! IT'S AN ARBITRARY NAME FOR A CLUSTER
#admix_cluster_assignment <- data.frame(sample_name = dplus2$sample_name, k2_pop = K2_clusters, k3_pop = K3_clusters)
```

```{r}
#object admix_cluster_assignment generated in cbp_admixture
#admix_cluster_assignment <- read.delim("~/Documents/PhD/Research/admixture/admix_cluster_assignment.txt")
```

Figuring out exactly who is in each group and where they are from.
```{r eval=FALSE}
# When K=3
k3_1 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop1"),]
# Taiwan, South East and North East China

k3_2 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop2"),]
# germany, poland, netherlands, iceland, sweden russia, NW China, NE France near Germany, near Scotland, SW France

k3_3 <- admix_cluster_assignment[which(admix_cluster_assignment$k3_pop == "pop3"),] #Italy Spain, Greece, Jordan, Algeria, Turkey
```

# European Only admixture
We are interested in how the Admixture group containing genotypes from northern Europe compare to NYC. I ran another admixture analysis only including individuals that have 60% or more ancestry proportion belonging to Population 3 when K=3 (Red individuals above).
```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
eu_fam <- read.delim(paste0(eu_admix_dir, "plink2_pruned_cbp.fam"), header=FALSE)

# read in Cross Validation (cv) error log
eu_cv <- read.delim(paste0(eu_admix_dir, "cv_error.log"), header = FALSE, sep = ":")

# list the files in admixture directory matching suffix pattern
#tbl <- list.files(path = admix_dir, pattern = "*.P") # .P files are allele frequencies of inferred ancestral populations; commented out because I do not use these files
lst <- list.files(path = eu_admix_dir, pattern = "*.Q") # Q files are ancestry fractions for each sample

eu_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(eu_admix_dir, file)  # Get the full file path
  eu_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}         
```

I have written functions for the plots I want and selecting K.
We can source the fuctions from capsella_pop_introgression_functions.R
```{r}
source("~/Documents/PhD/Research/capsella_introgression/capsella_pop_introgressin_functions.R")
```

```{r}
# plot cv error rate scatter and save selected K to K
K = selectK(eu_cv)
```

Variation between the CV error rates in incredibly small here, so there may be some merit to any of the K values above 2. However, K here is selected.

I will look at a ploot of all the K groupings together.
```{r}
eu_k2 <- ancestry_bars(eu_ancestry_propsK, K = K, sample_names_fam = eu_fam)

# save the ancestry/plot data
eu_k2_anc <- eu_k2$data
# make just the plot show up
plot(eu_k2)
```


A majority of the NYC samples are groups together within the same population.
```{r}
# print locations for "non-admixed" samples of each population

#Eurasia
eu_k2_anc[eu_k2_anc$ancestry == "pop2" & eu_k2_anc$proportion > 0.8,]

# NYC
eu_k2_anc[eu_k2_anc$ancestry == "pop1" & eu_k2_anc$proportion > 0.8,]
```

K = 4 also has a reasonably small cross validation error rate. It may be worth plotting all of these on a map to make them easier to interpret.

###### Ancestry maps
```{r combine ancestry with location info}
# make new column with the trailing S[number] removed from Panko samples
eu_k2_anc$sample_name <- str_remove_all(eu_k2_anc$vcf_sample_name, "_S[0-9]+")

# combine the sample info with ancestry
eu_k2_anc_info <- left_join(eu_k2_anc, wgs)
```

A majority of the samples have location data in latitude and longitude. For those that do not, I will check to see if I can generally place them on a map.
```{r no location genotypes}
# select those without latitude and longitude
no_locs <- unique(anc_info[is.na(anc_info$latitude) & is.na(anc_info$longitude), c("sample_name","citation", "note")])
```

All have a general location in the notes aside from the two samples from Kryvokhyzha. I am okay with those two dropping out of the dataset when I plot a map for now. For the rest, I will use a latitude and lonigtude given from their general location.
```{r}
#get city and state
no_locs$loc_name <- str_split_i(no_locs$note, pattern = ";", i=1)
#further split since I am having trouble passing directly to geocode
no_locs$city <- str_split_i(no_locs$loc_name, pattern = ",", i=1)
no_locs$country <-  str_split_i(no_locs$loc_name, pattern = ",", i=2)

# takes about 1 second per query
new_locs <- no_locs %>%
  geocode(city = city,
          country = country,
          lat = "latitude",
          long = "longitude")

new_locs <- new_locs[c("sample_name", "latitude", "longitude")]
```

Collate the new location information with larger ancestry dataframe.
```{r collate location data to all}
# update with new location information; matches by sample_name
anc_info <- rows_patch(anc_info, new_locs)

# check that only the two remaining samples do not have location info
# unique(anc_info[is.na(anc_info$latitude) & is.na(anc_info$longitude), c("sample_name","citation", "note")])
```

```{r}
eu_k2_anc_info <- ancestry_location(eu_k2_anc, wgs)
```

### Map Time!
```{r map of New York and New Jersey}
states <- ne_states(returnclass = "sf", country="United States of America")

# map of North America
ny_map <- ggplot(data= states)+ geom_sf(fill="gray93")+ coord_sf(xlim = c(-74.5, -73),  ylim = c(40.5, 41), expand = FALSE) + theme_light() + theme(axis.text.x= element_text(size = 5), axis.text.y= element_text(size = 5))
```



```{r}
ny_map + geom_point(data=subset(eu_k2_anc_info, state == c("NY", "NJ")), aes(x=longitude, y=latitude))
```
Color by ancestry proportion

Assigning ancestry by k groups
```{r}
#ancestry_datK <- list()
# for each K grouping
k2 <- ancestry_propsK[,c("pop1","pop2","pop3")]

K3_clusters <- colnames(dplus_pop3)[apply(dplus_pop3,1, which.max)]

#dplus_pop2 <- dplus2[,c("pop1","pop2")]
#K2_clusters <- colnames(dplus_pop2)[apply(dplus_pop2,1, which.max)]


#cluster assignments for samples

#### REMEBER THE POPULATIONS DO NOT MATCH BETWEEN K2 AND K3!!!!! IT'S AN ARBITRARY NAME FOR A CLUSTER
#admix_cluster_assignment <- data.frame(sample_name = dplus2$sample_name, k2_pop = K2_clusters, k3_pop = K3_clusters)
```

# Introgression in Capsella bursa-pastoris

```{r ancestry colors}
# another option for pink color is #C5839A; I was using "pink" before (FFC0CB), #E2A2B3, or just 'mistyrose'
anc.cols <- c(bursa_pastoris = "#a9ba9d", rubella = "#F1D1D9", heterozygous = "#96938E")

# a warm gray or green grey need to be quite dark for it to be appropriate for all forms of colorblindness
```

Load Ancestry HMM output
```{r ancestry_hmm output paths}
#paths to data output by Ancestry HMM
## posterior probabilities
ahmm_post_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_posterior/"

## viterbi decoding
ahmm_vit_path <- "~/Documents/PhD/Research/ahmm_local_inference/ahmm_viterbi/"

```

After running Ancestry HMM on the cluster, I have posterior outputs

```{r load posterior files, eval=FALSE}
tbl <- list.files(path = ahmm_post_path, pattern = "*.posterior") 

dat <- list()  # Create an empty list to store the data
#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_post_path, file)  # Get the full file path
  dat[[file]] <- read.delim(file_path, header = T)  # Read the file and store in the list
}                                                          
```

I got ride of the posterior probability decoding, so no plots are here and at this time, I do nothing with the posterior data.
# Viterbi decoding of ancestry

```{r load viterbi files}
# list all files with matching pattern
tbl <- list.files(path = ahmm_vit_path, pattern = "*.viterbi") 

vit <- list()  # Create an empty list to store the data

#loop to load sample data
for (file in tbl) {
  file_path <- file.path(ahmm_vit_path, file)  # Get the full file path
  vit[[file]] <- read.delim(file_path, header = F, col.names = c("chrom", "start", "end", "V4", "V5", "anc_state"))  # Read the file and store in the list
}                                

#change list element names
names(vit) <- str_replace_all(names(vit), "[.]viterbi", "") #remove file suffix from name
#names(vit) <- str_replace_all(names(vit), "_S[0-9]+", "") #remove S number from NYC samples
```


```{r reformat viterbi list}
# add factors for ancestral state and add tract-length column
vit_out <- lapply(vit, function(x) {data.frame(x) %>% mutate(ancestry = ifelse(anc_state == "2,0",
                  "rubella", 
                  ifelse(anc_state == "0,2",
                         "bursa_pastoris",
                         "heterozygous")), #assign ancestry
                  tract_length = end-start)}
                  ) # calculate tract lengths
```

```{r}
# concatenate the data tables for all the samples making a new column identifying the sample
vit_all <- data.table::rbindlist(vit_out, idcol = "vcf_sample_name")

# explicitly make 'vcf_sample_name' a factor and order by ancestry proportion
vit_all$vcf_sample_name <- factor(vit_all$vcf_sample_name, levels = lvl.order)
```


```{r landscape plot, eval=FALSE, echo=FALSE}
ggplot() + geom_segment(data = subset(vit_all, chrom == "SCF_9" & ), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

#ggsave("cbp_viterbi_SCF9_landscape.png", units = "in", height = 7, width = 12)
```

NA named individual in this sample set is 774. Sample is in ancestry HMM analysis but missing from ADMIXTURE analysis, so level ordering of samples sets 774 to NA.

###### Introgression .bed files
To use this tool, I need a bed file of introgressed regions for each sample separately.

I will start by combinging the viterbi decoding with the whole genome sequencing data
```{r}
# make new column with the trailing S[number] removed from Panko samples
vit_all$sample_name <- str_remove_all(vit_all$vcf_sample_name, "_S[0-9]+")

# combine the sample info with viterbi decoding
vit_all <- left_join(vit_all, wgs)

```
NYC only introgression plot
```{r nyc_introgression_plot}
ggplot() + geom_segment(data = subset(vit_all, (chrom == "SCF_16" & (state == "NY" | state == "NJ"))), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 16") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_viterbi_SCF16.png", units = "in", height = 7, width = 12)
```
```{r nyc_introgression_plot_allScaffolds}
ggplot() + geom_segment(data = subset(vit_all, (state == "NY" | state == "NJ")), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) +
  scale_color_manual(values=anc.cols) + 
  ggtitle("New York introgression patterns") + 
  ylab("position") + xlab("Sample Name") + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8)) +
   facet_wrap(~chrom, scales = "free_y")

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_viterbi_all.png", units = "in", height = 12, width = 19)
```
Starting with the NYC samples

```{r}
# select rubella tracts
ny_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & (vit_all$state == "NY" | vit_all$state == "NJ"),]
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- ny_rubella_tracts[,c("vcf_sample_name","chrom","start","end")]

# break up data frame by sample
ny_rub_by_sample <- split(temp, temp$vcf_sample_name)

# drop the sample id column from all
ny_rub_by_sample <- lapply(ny_rub_by_sample, function(x){
  x[,-"vcf_sample_name"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(ny_rub_by_sample)){
#   write.table(ny_rub_by_sample[[i]], paste0(names(ny_rub_by_sample)[i], "ny_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```

Now do the same for Mediterranean samples.

```{r}
# select rubella tracts
med_rubella_tracts <- vit_all[vit_all$ancestry == "rubella" & vit_all$vcf_sample_name %in% c("39-12-28","70.5","AL87","JO56","JO59","TR73","WAC5"),] #should be some other identifier
```

```{r prep data to be turned into bed file}
# select only useful columns
temp <- med_rubella_tracts[,c("vcf_sample_name","chrom","start","end")]

# break up data frame by sample
med_rub_by_sample <- split(temp, temp$vcf_sample_name)

# drop the sample id column from all
med_rub_by_sample <- lapply(med_rub_by_sample, function(x){
  x[,-"vcf_sample_name"]
})
```

save each to a separate .bed file
```{r, eval=FALSE}
# for(i in 1:length(med_rub_by_sample)){
#   write.table(med_rub_by_sample[[i]], paste0(names(med_rub_by_sample)[i], "med_rubella_chunks.bed"), col.names = F, quote = F, row.names = F, sep = "\t")
# }
```

### Commonly introgressed regions

This section uses the generated .bed files from each *Capsella bursa-pastoris* individual and *multi-inter* from BEDTools
```{r}
# load file
nyc_inter <- read.delim("~/Documents/PhD/Research/admixture/old/nyc_multiinter_rubella.txt")

# smaller working file since BEDTools outputs more information than I need
nyc_inter <- nyc_inter[,1:4]
```

```{r NY Crubella chunks gradient}
# mistyrose = #FFE4E1, violetred4 = #8B2252
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = nyc_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("New York introgressed region frequency") + theme_classic()

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_freq.png", units = "in", height = 12, width = 12)
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = nyc_inter, binwidth = 1, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
 
I will define an introgressed segment as common if it is present in at least 33 individuals (a little over 50% of our NYC samples)

```{r}
# get the common chunks
nyc_common_chunks <- nyc_inter[nyc_inter$num >= 33,]
```


```{r join common with nyc data}
#prepping to join with larger dataset
nyc_common_chunks$vcf_sample_name <- "common"
nyc_common_chunks$ancestry <- "rubella"

ny_rubella_common <- rbind(ny_rubella_tracts, nyc_common_chunks, fill=T)
```

```{r nyc and common rubella chunks}
ggplot() + geom_segment(data = subset(ny_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: New York") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))

# Looks quite good actually!
```


```{r nyc and common rubella chunks all}
ggplot() + geom_segment(data = ny_rubella_common, aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("New York introgrressed regions shared by 33 or more individuals") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10)) +
  facet_wrap(~chrom, scales = "free_y")

#ggsave("~/Documents/PhD/Research/capsella_local_ancestry/plots_temp/ny_introgressed_common.png", units = "in", height = 12, width = 19)
```


Now again with the Mediterranean samples
```{r}
# load file
med_inter <- read.delim("~/Documents/PhD/Research/admixture/old/med_rubella_chunks/med_multiinter_rubella.txt")

# smaller working file since BEDTools outputs more information than I need
med_inter <- med_inter[,1:4]
```

```{r NY Crubella chunks gradient}
# gradient plot where darker colors mean more individuals share an introgressed chunk
ggplot() + geom_segment(data = med_inter, aes(colour= num, x=chrom, xend=chrom, y=start, yend=end), linewidth = 10) + scale_color_continuous(high = "violetred4", low = "mistyrose") + ggtitle("Mediterranean introgressed regions") + theme_classic()
```

Let's look at the distributions of individuals that share chunks for each scaffold to get a better idea of how common is common for each scaffold.
```{r}
ggplot() + geom_histogram(data = med_inter, aes(x=num)) + facet_wrap(~chrom, scales = "free_y") +
  xlab("number of genotypes") + ggtitle("Genotypes sharing introgressed regions") + theme_bw()
```
 
I will define an introgressed segment as common here if it is present in at least 4 individuals from our Mediterranean group

```{r}
# get the common chunks
med_common_chunks <- med_inter[med_inter$num >= 4,]
```

### Med rubella tracts does not exist yet because I do not have a way to select
```{r join common with nyc data}
#prepping to join with larger dataset
med_common_chunks$vcf_sample_name <- "common"
med_common_chunks$ancestry <- "rubella"

med_rubella_common <- rbind(med_rubella_tracts, med_common_chunks, fill=T)
```

```{r nyc and common rubella chunks}
ggplot() + geom_segment(data = subset(med_rubella_common, chrom == "SCF_9"), aes(color= ancestry, x=vcf_sample_name, xend=vcf_sample_name, y=start, yend=end), linewidth = 8) + scale_color_manual(values=anc.cols) + ggtitle("Scaffold 9: Mediterranean") + ylab("position") + xlab("Sample Name") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10))
```


#### Genic Content
We may be interested in comparing the number of genes in introgressed regions vs non-introgressed regions. To do this, we can use BEDTools intersect to see how many basepairs of genes from a Genome Feature File (GFF) intersect with basepairs from introgressed or non-introgressed regions.

I will create BEDfiles of non-intorgressed regions as before.

#### PI in introgressed regions
To look at pairwise diversity in introgressed regions, first, I assigned individual Capsella bursa-pastoris to different populations where individuals are a part of 3 main lineages: Asian, with no introgression; Mediterranean, with introgression; and European/NewYorker, with introgression.

First, I looked at pairwise diversity in each population using sliding windows of 10,000 base pairs across the whole genome.

```{r whole genome pi, eval = FALSE}
### With the newly generated VCF
pi_v1 <- read.delim("~/Documents/PhD/Research/capsella_introgression_git_temp/windows_v1_pi.txt")

#plot
pi_v1 %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi across whole genome") +
  theme_bw()
```

Now for the nyc and mediterranean introgressed regions on their own.
```{r}
### With the newly generated VCF
pi_nyc <- read.delim("~/Documents/PhD/Research/capsella_introgression_git_temp/nyc_int_v1_pi.txt")

#plot
pi_nyc %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi in NYC introgressed regions only")
  
```
An interesting comparison here might be between NYC samples and other (northern) European cluster samples.

```{r}
### With the newly generated VCF
pi_med <- read.delim("~/Documents/PhD/Research/capsella_introgression_git_temp/med_int_v1_pi.txt")

#plot
pi_med %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~pop) +
  ggtitle("Pi in Mediterranean introgressed regions only")
```
Not sure that this means yet, but my first thoughts are that for commonly introgressed regions in the mediterranean

#### SIDEBAR
I wonder if we zoom in on Pi in NYC for introgressed regions that are present in all 65 individuals.
```{r}
# select regions present in all individiuals
nyc_retained_chunks <- nyc_inter[nyc_inter$num == 65,]

# save whole genome data as ggplot
wg_nyc_pi <- pi_v1[pi_v1$pop == "p2_nyc",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi))+
  geom_line()

# plot only those regions?
pi_nyc[pi_nyc$pop == "p2_nyc",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  ggtitle("Pi in NYC introgressed regions only")

# plot only those regions?
int_r_nyc_pi <- pi_nyc[pi_nyc$pop == "p2_nyc",] %>%
  mutate(chr_position = ((window_pos_1 + window_pos_2)/2)/1000000) %>%
  ggplot(aes(x = chr_position, y = avg_pi, color = chromosome))+
  geom_line() +
  facet_wrap(~chromosome)
  ggtitle("Pi in NYC introgressed regions shared by >=33 genotypes")
```

